[comment]: <browser> (title: '浏览器里的进程和线程', keywords: 'process, thread, browser', date: '2020-7-30')

## 浏览器里的进程和线程

现在的浏览器都是多进程的应用，通常来讲每开一个tab浏览器就会为其创建一个新的渲染进程。
一个完善的浏览器通常包括以下进程：
* 浏览器主进程，主要负责浏览器自身的UI，页面最终的呈现，tab页和窗口的管理，web资源（网络，文件，传感器）的请求和管理等
* 渲染进程，上面提到过了
  * 如iframe，extension扩展等都会有自己的渲染进程
  * 从一个页面打开同一个根域名和协议的新tab，这时两个tab会共用一个渲染进程
* GPU进程，只有一个，负责独立于其他进程的GPU任务
* 插件进程，用来支持页面嵌入的插件，最常用的就是flash，嵌入式插件已经不推荐被使用了

这些进程本身都会包含多个线程来分担任务，除此之外，现代浏览器通常还会包含其他的辅助进程。

这些进程中与页面直接相关的就是**渲染进程**，浏览器进程会将下载好的代码交给渲染进程。
渲染进程本身包含了多个线程，主要有：

* GUI线程，负责网页绘制
  * 渲染主线程
    * 处理html，生成或者更新dom树，当解析到静态资源时向主进程中的网络线程提交请求
      * css的解析不会阻塞dom树构建但是会阻塞渲染，也会阻塞之后的JS执行；
      * 同步的js则会阻塞dom树构建，渲染
    * 解析css成样式规则表，和dom树合并生成或更新渲染树，渲染树只会包含可见的节点
    * 计算元素的具体样式和布局，生成或更新布局树
    * 计算元素的层次信息，生成或更新图层树。解析，布局和分层是很复杂的过程，它们是web规范的核心体现。
    * 为每个图层生成绘制列表（绘制指令）
    * 启用GPU加速的元素会被提升成独立的渲染层（合成层），它有自己独立的图形上下文，主要是为了优化动画效果：
      * 3D transform，css filter，opacity transition，will-change，启用硬解加速的video或采用WebGL的canvas等
      * 合成层的位图合并是GPU来做的会更快；重绘不会影响其他层；对于一些动画效果无需重绘和回流
      * 有的图层本身包含合成层并且具备一些特殊属性或者与合成层有某些情况下的重叠，都有可能造成自身也被提升为合成层的情况，太多的合成层会显著影响渲染性能，一个优化方法是使用z-index显式的提高合成层的层级
  * 合成线程
    * 合成线程将不同的图层分块并将图块提交给栅格化线程池执行栅格化(光栅化)操作生成位图
    * 合成线程发送绘制命令将位图提交给浏览器主进程或者GPU进程，位图合并然后执行最终的渲染
* JS线程，负责执行JavaScript
  * GUI线程和JS是互斥的（因为JS会操作DOM），同一时刻只能有一个执行
* 事件触发线程，负责任务队列的调度和轮询
* 定时器线程，处理`setTimeout`和`setInterval`，它们需要经过一段时间才能被放入任务队列
* http请求线程，每次发起请求都会有新的线程来负责此次的请求生命周期
* WebWorker线程，单独运行worker脚本（注意它与SharedWorker是不同的，后者是独立于所有页面的单独进程）

实际的运行中，以上各种线程和进程会互相通信，各取所取，最终完成页面的渲染和响应。

了解了这些线程的职责，我们就能了解浏览器在一帧的时间内做了什么事情：

* 垂直同步信号（可以理解为屏幕渲染时钟信号）触发开始渲染新的一帧
* 处理用户事件回调，执行当前的宏任务和所有的微任务
* 执行`requestAnimationFrame`以及`IntersectionObserver`回调
* 处理html的变化，更新dom
* 重新计算样式
* 重新计算布局树
* 更新图层树
* 重新生成绘制指令
* 合成线程处理图层，执行栅格化操作
* 合并位图并提交给GPU
* GPU将收到的图块（纹理）渲染到屏幕上
* 有额外时间则执行`requestIdleCallback`

任何脚本的执行如果耗时太久都会导致浏览器在一帧中没有额外的时间处理渲染的事情，从而导致丢帧和卡顿。

