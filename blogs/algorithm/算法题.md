### 算法题
<ol>
<li>
<details>
  <summary>
    <a  href="https://leetcode-cn.com/problems/merge-intervals/">合并重叠区间</a>
  </summary> 
  
  合并重叠的区间
  1. 按左端升序排列
  2. 将第一个元素加入解集，之后考虑剩下每个区间
  3. 如果不重合直接加入解集，否则取当前区间右端和解集最后区间右端最大值更新为解集最后区间右端的值
</details>

<li>
<details>
  <summary>
    <a  href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">最长无重复字符子串</a>
  </summary> 
  
  滑动窗口
  1. 窗口右端不断向右判断，
  2. 如果没有重复字符，右端继续向右移动；
  3. 如果有重复字符，记录此时窗口长度，然后左端窗口向右移动，继续上述过程
</details>

<li><details>
  <summary>
    <a  href="https://leetcode-cn.com/problems/3.sum/">三数之和</a>
  </summary> 
  
  一个数组找出有没有三个不同的数之和为0

  1. 首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，
  数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进解集
  2. 如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环
  3. 如果 nums[i] == nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过
  4. 当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++
  5. 当 sum == 0 时，nums[R] == nums[R-1] 则会导致结果重复，应该跳过，R--
</details>

<li>
<details>
  <summary>
    <a  href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a>
  </summary>
  
  一个数组，每个数字想象成围栏，倒水之后形成的最大面积
  双指针
  1. 前后指针分别指向数组首尾，然后向中间移动
  2. 每次只移动一个指针，哪个小就移动哪个，然后计算面积
  3. 输出其中最大的面积
</details>
<li>
<details>
  <summary>
    <a  href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a>
  </summary>
  
  中心扩展算法 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/si-lu-fei-chang-jian-ji-zhi-you-san-ju-h-bh86/">题解</a>
  1. 考察每个字符，以此为中心向两边遍历，相同则继续，否则无法构成回文结构则结束，记录结果
  2. 但是需要考虑奇数回文串和偶数回文串两种情况，偶数就要以两个相同字符作为中心
</details>

<li>
<details>
  <summary>
    <a  href="https://leetcode-cn.com/problems/coin-change/">硬币兑换</a>
  </summary>

  动态规划 <a href="https://leetcode-cn.com/problems/coin-change/solution/wan-quan-bei-bao-de-zui-zhi-wen-ti-wai-c-flro/">题解</a>
1. 当选择最后一枚硬币恰好凑成所需金额，假设此时硬币数量是最小的，那么说明count(amount-lastCoin)（子问题）也是最少的
2. 所以需要定义dp数组为dp[i]表示金额为i时的最少硬币数量，dp[i]=min(dp[i], dp[i-someCoin] + 1)
</details>

<li><details><summary><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></summary>
策略：下一个排列总是比当前排列大并且二者总是最接近的

1. 从当前排列a的后面开始寻找，如果一直递增就继续寻找，直到遇到第一个递减的数b
2. 然后重新从a的后面开始寻找，直到找到第一个比b大的数字c，然后交换b和c
3. 最后将当前c之后的数字（递减排列）反转成递增
4. <img src="https://assets.leetcode-cn.com/solution-static/31/31.gif" width="200">
