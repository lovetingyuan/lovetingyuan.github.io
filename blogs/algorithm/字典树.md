### 字典序的第 K 小的数字是多少

给定整数 n 和 k，返回 [1, n] 中字典序第 k 小的数字。
[leetcode](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

```log
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

![字典树](https://assets.leetcode-cn.com/solution-static/440/440_1.PNG)

```js
var findKthNumber = function (n, k) {
  // 字典树就是层次遍历是按照123的顺序，但是前序遍历才能得到字典序
  // 下面的思路就是先计算k在第几个子树中，再计算k在它所在子树中第几个位置
  const maxLevel = String(n).length // 字典树最大层数
  const lastLevelFirstNode = 10 ** (maxLevel - 1) // 最后一层最左边的节点值
  const lastLevelNodes = n - lastLevelFirstNode + 1 // 最后一层的节点数
  const lastNodeTreeIndex = String(n)[0] - 0 // 最后的节点所在的子树的序号
  let kIndex = 1 // k节点所在的子树的序号
  let nodes = 0
  let prevNodes = 0
  const fullNodes = (10 ** maxLevel - 1) / 9
  const lessFullNodes = (fullNodes - 1) / 10
  // 遍历子树，计算节点数加和，找到k在第几个子树以及在所属子树的位置
  for (let i = 1; i <= 9; i++) {
    if (i < lastNodeTreeIndex) {
      nodes += fullNodes
    } else if (i === lastNodeTreeIndex) {
      nodes += lessFullNodes + lastLevelNodes - (lastNodeTreeIndex - 1) * lastLevelFirstNode
    } else {
      nodes += lessFullNodes
    }
    if (nodes >= k) {
      kIndex = i
      break
    }
    prevNodes = nodes
  }
  const targetTreeIndex = k - prevNodes
  let result
  let index = 0
  let node = kIndex
  const list = []
  // 迭代法进行前序遍历
  while (index++ < targetTreeIndex) {
    result = node
    const nextNode = node * 10
    if (nextNode > n) {
      node = list.pop()
    } else {
      node = nextNode
      for (let i = 9; i > 0; i--) {
        if (nextNode + i > n) break
        list.push(nextNode + i)
      }
    }
  }
  return result
}
```
