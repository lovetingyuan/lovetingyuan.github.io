## React Server Components

React服务器组件的几个原则：

1. React 服务器组件只在服务器端运行一次，然后响应序列化后的渲染结果，这个渲染结果在客户端也不会再变化。这意味着服务器组件并不会涉及状态以及副作用。
2. 服务器组件不会打包到js bundle当中，只在服务器存在
3. 客户端组件可以在浏览器和服务器运行
4. 所有的组件默认是服务器组件，但是可以用 `"use client"` 来标记一个组件为客户端组件
5. 客户端组件只能渲染客户端组件，并且在客户端中引用的组件也都应该是客户端组件，引用的模块也都应该是客户端的模块

   ```jsx
   function Client() {
     return (
       <div>
         this is client component
         <Server /> // 不合法！！！
       </div>
     )
   }
   ```

   ```jsx
   function Client(props) {
     return (
       <div>
         this is client component
         {props.serverComponent} // ok
       </div>
     )
   }
   ```

https://sorrycc.com/why-react-server-components/

---------

# React Server Components (RSC) 的目的与优势

## 引入 RSC 的主要目的

1. **结合服务器和客户端的优势** - 创建一个统一的开发模型，让开发者能同时利用服务器和客户端各自的优势

2. **改善性能和用户体验** - 通过减少网络传输和优化渲染流程，提供更快的加载速度和响应性

3. **简化复杂应用架构** - 为开发者提供更自然的编程模型，减少在服务器和客户端之间切换的心智负担

4. **减少客户端 JavaScript 体积** - 降低需要发送到浏览器的代码量，特别是对于只需要在服务器上运行的组件

5. **提高应用可维护性** - 允许更清晰地分离关注点，使代码库更易于理解和维护

## RSC 的核心优势

### 1. 零捆绑 JavaScript 负载

- 服务器组件不需要发送到客户端，只有渲染结果被传输
- 大幅减少客户端下载、解析和执行的 JavaScript 代码量
- 特别有益于网络连接较慢或设备性能有限的用户

### 2. 直接访问后端资源

- 服务器组件可以直接访问数据库、文件系统和后端服务
- 消除了传统 API 层的需求，简化了数据获取流程
- 减少了客户端-服务器通信的往返次数

### 3. 自动代码分割

- RSC 架构自然支持细粒度的代码分割
- 客户端只接收实际需要在浏览器中运行的组件代码
- 无需手动配置复杂的代码分割策略

### 4. 流式渲染

- 支持渐进式内容流式传输到客户端
- 用户可以更快看到页面的初始内容，而不必等待所有数据加载完成
- 改善了感知性能和用户体验

### 5. 更好的安全模型

- 敏感逻辑和数据处理可以保留在服务器上
- 减少了客户端暴露的攻击面
- API 密钥和认证凭证可以安全地保存在服务器端

### 6. 跨环境组件组合

- 服务器组件和客户端组件可以无缝协作
- 开发者可以根据组件的需求选择最合适的环境
- 保持了 React 组件模型的统一性和可组合性

### 7. 更简洁的数据获取模式

- 减少了客户端状态管理的复杂性
- 无需使用 useEffect 进行数据获取
- 通过共置数据获取和组件渲染逻辑，提高了代码可维护性

### 8. SEO 和初始加载优化

- 服务器渲染确保搜索引擎能够看到完整内容
- 改善了首次内容绘制 (FCP) 和首次有意义绘制 (FMP) 指标
- 无需额外配置就能实现良好的 SEO 性能

### 9. 开发体验改进

- 统一的编程模型减少了上下文切换
- 更自然的数据获取和状态管理方式
- 简化了构建全栈 React 应用的流程

### 10. 与现有 React 生态系统兼容

- 可以逐步采用 RSC，无需一次性重写整个应用
- 现有的客户端组件可以与新的服务器组件共存
- 保持了 React 熟悉的编程模型和组件抽象

-----------------------
# React Server Components (RSC) 相比 SSR 的独特优势

## RSC 与 SSR 的关键区别

SSR（Server-Side Rendering）主要专注于将完整的组件树在服务器上渲染为 HTML，然后发送到客户端进行水合（hydration）。而 RSC（React Server Components）采用了一种根本不同的方法，提供了 SSR 无法实现的独特优势。

## RSC 相比 SSR 的独特优势

### 1. 零客户端 JavaScript 组件

- **RSC**: 服务器组件的 JavaScript 代码完全不发送到客户端，只传输渲染结果
- **SSR**: 即使是服务器渲染的组件，其 JavaScript 代码仍然需要发送到客户端进行水合

### 2. 无需客户端水合过程

- **RSC**: 服务器组件不需要在客户端进行水合，避免了水合过程中的性能开销
- **SSR**: 完整的水合过程是必需的，这会导致额外的 JavaScript 处理和可能的布局偏移

### 3. 细粒度组件层面的服务器/客户端分离

- **RSC**: 可以精确到单个组件级别决定是在服务器上运行还是在客户端上运行
- **SSR**: 通常是整页渲染，没有提供组件级别的灵活性

### 4. 服务器与客户端组件无缝组合

- **RSC**: 提供了一个统一的组件模型，服务器组件可以包含客户端组件，反之亦然
- **SSR**: 没有清晰的组件级分离模型，整个组件树都需要能够在服务器和客户端上运行

### 5. 保持服务器状态而无需序列化

- **RSC**: 服务器组件可以访问无法序列化的资源（如数据库连接），而无需将其转换为可序列化形式
- **SSR**: 需要确保所有状态都是可序列化的，以便在客户端重建

### 6. 更智能的数据传输格式

- **RSC**: 使用特殊的流式 RSC 格式传输数据，更高效地表示 React 组件树
- **SSR**: 传输完整的 HTML 页面和 JavaScript 代码

### 7. 增量采用和更新能力

- **RSC**: 支持增量内容更新，无需刷新整个页面
- **SSR**: 通常需要进行完整页面刷新或依赖客户端 JavaScript 来更新内容

### 8. 改进的数据获取模型

- **RSC**: 组件可以直接声明其数据依赖，框架能智能处理数据获取和缓存
- **SSR**: 通常需要使用 getServerSideProps 或类似 API，数据获取模型相对僵化

### 9. 自动优化加载顺序

- **RSC**: 可以智能地确定组件加载优先级，优先显示关键内容
- **SSR**: 需要开发者手动管理和优化内容加载顺序

### 10. 更精细的缓存控制

- **RSC**: 支持组件级别的缓存策略，不同组件可以有不同的缓存行为
- **SSR**: 通常是页面级别的缓存，难以实现更细粒度的控制

### 11. 运行时环境选择的灵活性

- **RSC**: 开发者可以明确选择每个组件的运行环境（服务器或客户端）
- **SSR**: 所有组件代码都必须能够在服务器和客户端环境中运行

### 12. 真正的服务器端逻辑

- **RSC**: 服务器组件中的代码永远不会在客户端执行，可以安全地包含敏感逻辑
- **SSR**: 服务器代码最终也会发送到客户端，需要小心处理敏感逻辑

