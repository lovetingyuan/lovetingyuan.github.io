## React性能优化

### 使用 React.memo (PureComponent or shouldComponentUpdate)

1. 使用 `memo` 来尽量避免React组件不必要的重渲染（尤其是对于大而重的组件），因为大部分情况下我们期望的是props变化组件才重渲染。但是值得注意的是单纯的使用 `memo` 是很脆弱的，比如我们经常向组件属性传递对象字面量或者函数，这都很可能无法实现这样的优化初衷

2. 对于传递给组件的props，如果是对象类型的属性，我们可以使用 `useMemo` `useCallback` `useRef` 来减少引用的变更

3. 更进一步的，我认为应该尽量减少组件的props数量，props过多不利于达成 `memo` 的优化，很多组件用不到某些props但是为了传递它们而不得不接收从而造成props drilling。其实很多时候我们是可以把（并且也应该这样）组件的状态或者属性放到外部store中的，我们在组件内部订阅和消费这些外部状态，而不是通过props去传递。

### 尽量减少re-render

1. 除了memo的手段外，还需要注意在编码的时候避免不必要的重渲染。最常见的情况是，过度依赖状态变更来触发新的状态变化，例如在 `useEffect` 中触发新的状态变化。大部分的状态变化其实都可以放到事件处理函数中。
2. 另外需要尽量避免定义过多的状态，如果多个状态是整体的就应该合并成一个状态；如果有的状态是可以派生的，那就不应该定义而是应该直接计算。

### 使用 useMemo useState-lazy-initializer

1. 对于计算昂贵的数据或者昂贵的组件（jsx），可以使用 `useMemo` 来进行缓存
2. 对于数据量比较大的状态，我们可以给 `useState` 传递一个函数，因为这个函数只会执行一次

### 使用 startTransition useTransition useDeferredValue

1. 如果某些状态更新会导致一些长任务的话，可以使用 `startTransition` 来包裹，比如当你发现某些状态变化引起的组件重渲染导致UI卡顿的时候，可以使用 `startTransition`，这样状态更新的优先级会被降低而优先保证UI的流畅
2. 如果某个状态会频繁快速的更新而导致部分UI频繁重渲染，可以使用 `useDeferredValue` 来获取一个类似于防抖版本的值，这样可以避免某些UI频繁更新

### 谨慎更新 React.Context 的value

React Context中的值变化时，访问到这个context的组件都会重新渲染，正确的做法是将 Context根据不同的value属性来拆分

### 合理拆分和组合组件

避免很长的组件。组件的职责应该单一，所以它本应该就不应该大而杂乱。也许你只是更新了一个文本需要用到的状态，但是整个组件都要重新渲染。

1. 可以解耦的逻辑一律放到组件外部，组件内部只负责调用，传递值，获取结果
2. 可复用的状态和逻辑一律包装成hook
3. 考察组件是否可以拆分为不同的更小的组件，如果可以抽离新的组件，那就意味着避免了相应的状态变更引起其他无关的UI部分的重渲染

### React Compiler

https://react.dev/learn/react-compiler

另外还有一些跟性能有关的值得注意的点，例如合理的使用 `key`；避免组件层级过深，节点数量过多；谨慎在高层级的组件处进行状态变更；延迟渲染，缓存渲染（长列表、tab、dialog等）；组件异步拆分；组件单例化等

最后不要过分追求react性能的优化，发现了性能问题再去优化，代码的可读性和可维护性远比一些细微的性能优化更值得投入精力。
