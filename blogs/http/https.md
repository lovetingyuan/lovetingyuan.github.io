[meta]: <http> (title: 'https协议', keywords: 'https, tls, ssl', date: '2020-8-22')

## https协议

https = http + SSL/TLS, SSL/TLS是http之下的一层额外的安全协议，用来保证http传输的内容是被加密的
最初的协议采用SSL，共经历了三个版本，后续的版本改称为TLS

### TLS
TLS被称为传输层安全协议，最新的版本是`TLS 1.3`，实际中1.1和1.2是使用比较广泛的，它是介于传输层和应用层之前的一层协议，可以为很多应用协议提供安全保证，比如https, ftps, smtps, wss, dns over tls等
大致的工作流程：
1. 客户端向服务器端索要并验证公钥；
2. 双方协商生成"对话密钥"；
3. 双方采用"对话密钥"进行加密通信；
前两个阶段被称为握手阶段，这一阶段采用非对称加密，实际的数据通信采用的是握手阶段协商好的密钥进行对称加密

### 握手阶段（TLS1.2）

握手阶段分为四次，2个RTT时间，握手的过程一是为了确认服务端身份及公钥的合法性（由证书保证），二是完成主密钥协商（由密钥协商算法保证）：
1. 客户端发起请求，将支持的协议版本、加密套件列表、压缩方法(TLS1.3不再启用压缩)以及一个随机数发送给服务端
2. 服务端收到请求，将选定的协议版本、加密方法、一个随机数，会话ID返回给客户端，之后会将证书链以及公钥返回给客户端
   * 如果是DH算法，服务端还会生成DH算法所需的服务端参数，然后用私钥将该参数以及双方的随机数做签名并连同参数一起返回给客户端
4. 客户端收到响应，校验证书，通过后会用证书公钥加密一个随机数生成预主密钥、密码规范更改通知（表示后续开始采用对称加密）和完成通知（包含之前的会话指纹）发送给服务端
   * 如果是DH算法，客户端还会校验之前发送过来的参数签名，通过后会将客户端DH参数发送给服务端
   * 此时预主密钥是通过DH算法根据两个参数计算得到的，而不再是由随机数产生
6. 服务端收到请求，用私钥解密出预主密钥，然后向客户端发送密码规范更改确认通知以及完成通知（包含之前的会话指纹）给客户端
7. 之后双方各自使用相同算法根据随机数和预主密钥生成会话密钥，并用其对协商结束信息进行对称加密后发送给对方，消息解密无误之后开始正式的数据加密通信

双方都有两个随机数以及一个预主密钥，三者通过`PRF`算法生成主密钥，主密钥再生成会话密钥，用于数据的对称加密。双方提供的随机数可以增加随机性，防止重放，从而提高安全程度。

根据选定的加密套件双方一般都还需要额外交换一些加密用到的参数，比如DH类算法中的`DHE_RSA`(离散对数问题)或`ECDHE_RSA`(椭圆曲线离散对数问题)等，但是RSA就不需要。但RSA不是前向安全(PFS)的算法，也就是说一旦服务器私钥泄露，之前的会话都能被解密，所以现在一般采用带数字签名的`DHE`算法，双方只需要交换各自的参数，算法即可保证生成同一个预主密钥，无需私钥参与。

### 证书校验

客户端必须校验收到的证书的合法性，避免中间人攻击(`MITM`)，这一过程通过校验数字签名来完成。

证书由数据和签名组成，
* 数据部分包括，证书版本号，序列号，签名算法，签发机构，有效期，拥有者，扩展信息等
* 签名附在证书的末尾，`Signature = RSA(sha256(Data), IssuerPrivateKey)`，这个`IssuerPrivateKey`是CA机构签发证书时用的私钥，是绝密的。

服务器证书一般是由二级机构签发的，二级机构的证书有顶级CA根证书签发，校验的时候要用上级证书的公钥解开签名拿到数据部分的hash指纹，然后计算数据部分的指纹，对比二者，相同的话然后校验数据部分，包括域名，有效期等，再向上执行相同的校验过程直到使用根证书（内置在浏览器和系统中）校验通过才算证书有效，否则客户端会提示警告证书无效。这个过程是客户端校验服务端证书，称为单向认证，实际上服务端也可以请求客户端发送证书，客户端会在握手第三步把自己的证书发给服务端认证。

证书如果在有效期内被吊销了，实际上也是无效的证书了，这个吊销与否是个动态的查询过程，一般有`CRL`和`OCSP`两种方式，访问CRL可以拿到吊销列表，里面包含了近期被吊销的证书，但是实时性并不好，更好的方式是访问OCSP，它会直接返回证书是否被吊销。当然OCSP的缺点也很明显，一是多一次通信就会变慢，二是这个通信也不一定会成功。

### TLS 1.3

1.3实际算是个大版本更新，带来了更好的性能和安全性。TLS1.3总共有两层，分别是握手协议(handshake protocol)和记录协议(record protocol)，握手协议在记录协议的上层，用来执行握手流程，记录协议是一个分层协议，用来执行数据的加解密和验证等工作。其中握手协议中还包括了警告协议(alert protocol)。
* 更好的性能，1.2是需要2个RTT时间，1.3变成了1个RTT，甚至是0 RTT，另外新的加密算法也具备更好的性能
  * RTT缩短的原因是将1.2的算法参数协商的过程合并了，客户端首次请求就会携带上选用的算法以及对应的参数
* 更好的安全性，一是废除了很多安全性不够的算法如SHA1，MD5，RSA，CBC，RC4，3DES，DH等，二是对绝大部分握手信息也进行了加密
  * 密钥协商算法现在只支持`DHE`和`ECDHE`(ECDHE-RSA,ECDHE-ECDSA,DHE-RSA)加密以及`PSK`(可以实现0 RTT)两种机制；`DHE`算法需要双方各自生成一对密钥，在第一次握手时客户端把自己的公钥和加密算法参数发给服务端，服务端用证书对自己的公钥签名返给客户端，双方都知道各自的公钥和加密参数就能依靠自己的密钥计算出一个相同的密钥；`PSK`在安全信道建立的情况下，双方可以协商若干个会话密钥，每个密钥都有自己的ticket，之后会话重启时就可以只发送ticket来确定新的会话密钥；
  * 采用新的密钥导出函数`HKDF`替代之前的`PRF`算法，具有更好的随机性；
  * 对称加密算法套件也只保留五种：TLS13-AES-256-GCM-SHA384, TLS13-CHACHA20-POLY1305-SHA256, TLS13-AES-128-GCM-SHA256, TLS13-AES-128-CCM-8-SHA256,TLS13-AES-128-CCM-SHA256（这些算法使用同一密钥长期加密后安全性会下降，此时双方需要再次使用`HKDF`来确定新的会话密钥）
  * 另外还有一些不安全的机制被废弃，如DSA证书，重协商机制，报文压缩，SessionId和SessionTicket会话恢复机制等
