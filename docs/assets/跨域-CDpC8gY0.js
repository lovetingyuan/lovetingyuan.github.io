import{o,f as l,O as i}from"./vendor-y_6yhxmk.js";const r={class:"markdown-body"},c=i('<h2>跨域</h2><h4>同源</h4><p>协议+域名+端口 一致表示同源</p><h4>解决办法</h4><ul><li>CORS</li><li>jsonp</li><li>postMessage</li><li>WebSocket</li><li>服务器代理</li><li>iframe + window.name/location.hash/document.domain</li></ul><h3>CORS</h3><p>简单请求：</p><ul><li>请求方法：GET, HEAD, POST</li><li>content-type 只能是： <ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li>header 只能包含 <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li></ul><blockquote><p>区分简单请求和复杂请求是为了兼容表单提交请求（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p></blockquote><p>复杂请求</p><p>复杂请求在发出之前会发送<code>OPTIONS</code>预检请求，通过之后才会发送复杂请求（之所以需要预检请求，是因为需要让后端判断这个跨域请求是不是合法的，否则请求直接打到后端会造成负面影响）</p><ul><li>Access-Control-Request-Method</li><li>Access-Control-Request-Headers</li></ul><p>复杂请求相关头部</p><ul><li>Access-Control-Allow-Origin</li><li>Access-Control-Allow-Credentials</li><li>Access-Control-Expose-Headers // 客户端能获取到的 header</li><li>Access-Control-Allow-Methods</li><li>Access-Control-Max-Age // 预检请求的缓存有效期</li></ul><h3>对于cookie的限制</h3><p>跨域请求默认不会携带cookie，如果要携带cookie</p><ul><li>后端 Response header 有 <code>Access-Control-Allow-Credentials: true</code></li><li>后端 Response header 的 <code>Access-Control-Allow-Origin</code> 不能是 <code>*</code>，要明确指定</li><li>前端 fetch 加上 credentials: ‘include’</li></ul><p>对于简单请求，只需要符合第三个要求，对于非简单请求来说，三个条件都要满足。</p><p>另外虽然跨域不一定会跨站，但是如果涉及到跨站还需要考虑<code>SameSite</code>带来的限制。</p><h3>其他针对跨域的保护策略</h3><ol><li><p>CORB</p><p><a href="https://www.chromium.org/Home/chromium-security/corb-for-developers/" target="_blank" rel="noopener">Cross-Origin Read Blocking</a>，虽然跨域限制已经阻止了响应给到JavaScript，但是对于像图片或者脚本之类的资源，浏览器仍然会请求并解析响应给渲染进程，在这之前浏览器并不能确保img加载的资源就是图片类型，假设如果是json类型（或者是html及xml类型），没有CORB的保护，json会被渲染进程读取，有可能会造成数据泄露（例如Spectre漏洞）。有了CORB对于类型错误的资源浏览器会直接丢弃。</p></li><li><p>CORP</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy" target="_blank" rel="noopener"><code>Cross-Origin-Resource-Policy</code></a>是一个http的header，可以设置<code>same-site</code>, <code>same-origin</code>, <code>cross-origin</code>。浏览器很多资源是不会对跨域做限制的，可以正常加载，例如图片视频等，但是如果我们想要对这些资源的来源做限制就可以给它们加上这个http头（当然这个也可以做到防盗链）</p></li><li><p>COEP</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy" target="_blank" rel="noopener"><code>Cross-Origin-Embedder-Policy</code></a>，也是一个http header，可以取<code>unsafe-none</code>, <code>require-corp</code>，其中设置为<code>require-corp</code>的含义表示浏览器加载的所有资源都必须设置正确合法的CORP头</p></li><li><p>COOP</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy" target="_blank" rel="noopener"><code>Cross-Origin-Opener-Policy</code></a>，同样是一个http header，可以取<code>unsafe-none</code>,<code>same-origin</code>,<code>same-origin-allow-popups</code>等值，它主要用来限制在A页面通过<code>window.open</code>打开B页面后，两者通过<code>opener</code>的可访问性问题。</p></li></ol>',21),t=[c],h={__name:"跨域",setup(s,{expose:e}){return e({frontmatter:{}}),(d,p)=>(o(),l("div",r,t))}};export{h as default};
