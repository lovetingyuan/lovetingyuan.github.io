import{o as i,e,M as t}from"./vendor-B7iAV6MF.js";const o={class:"markdown-body"},a=t('<h2>浏览器里的进程和线程</h2><p>现在的浏览器都是多进程的应用，但是在早之前（2007年），浏览器是单进程的，里面包含多个线程来负责网络，页面渲染等任务，这样带来的问题包括：</p><ul><li>不稳定，一个线程崩溃往往导致整个进程的崩溃</li><li>性能差，例如负责页面渲染的线程就需要负责页面解析，渲染，js执行，运行插件等任务，每一个任务阻塞都会影响其他任务的执行；另外如果页面存在内存泄漏，线程不关闭是无法回收的，这也会影响性能</li><li>不安全，线程是可以共享进程的一部分数据的，如果插件或脚本利用漏洞就会影响其他页面的安全</li></ul><p>一个现代完善的浏览器通常包括以下进程：</p><ul><li>浏览器主进程，主要负责浏览器自身的 UI，页面最终的呈现，tab 页和窗口的管理，web 资源（网络，文件，传感器）的请求和管理等</li><li>渲染进程，通常来讲每开一个 tab 浏览器就会为其创建一个新的渲染进程。 <ul><li>如 iframe，extension 扩展等都会有自己的渲染进程</li><li>从一个页面打开同一个根域名和协议（即同站）的新页面，这时两个页面有可能会共用一个渲染进程，例如使用window.open</li><li>实际上包括渲染进程在内的很多进程都运行在称为沙箱的环境中，它们无法直接进行高风险的调用，需要与主进程通信</li></ul></li><li>GPU 进程，只有一个，负责独立于其他进程的 GPU 任务</li><li>网络进程，用来负责网络资源加载（从浏览器主进程中分出来了）</li><li>插件进程，用来支持页面嵌入的插件，最常用的就是 flash，大多数嵌入式插件已经不推荐被使用了</li></ul><p>这些进程本身都会包含多个线程来分担任务，除此之外，现代浏览器通常还会包含其他的辅助进程。</p><p>这些进程中与页面直接相关的就是<strong>渲染进程</strong>，浏览器进程会将下载好的代码交给渲染进程。 渲染进程本身包含了多个线程，主要有：</p><ul><li><p>GUI 线程，负责网页绘制</p><ul><li>渲染主线程（用来一帧一帧地执行js、更新dom、样式、渲染等工作） <ol><li>处理 html，生成或者更新 dom 树，当解析到静态资源时向主进程中的网络线程提交请求 <ul><li>css 的解析不会阻塞 dom 树构建但是会阻塞渲染，也会阻塞之后的 JS 执行；</li><li>js 执行时会阻塞 dom 树构建（如果是同步js，那么从下载开始就会阻塞了）；</li></ul></li><li>解析 css 成样式规则表，和 dom 树合并生成或更新渲染树</li><li>计算元素的具体样式和布局，生成或更新布局树（只包含可见节点） <ul><li>对于页面更新渲染的过程来说，重新计算布局或者图层可能会被跳过，这取决于样式更改属于重排还是重绘</li><li>值得注意的是，不是只有显式的更改元素的样式才会触发重绘或重排，js读取一些样式，尤其是尺寸相关的属性时也会触发重排</li></ul></li><li>计算元素的层次信息，生成或更新图层树，每个节点都会直接或间接归属于某个图层。（解析，布局和分层是很复杂的过程，它们是 web 规范的核心体现。） <ul><li>创建图层最常见的方式是触发<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context" target="_blank" rel="noopener">层叠上下文</a></li><li>如果一个元素需要被裁剪或者出现滚动条，也会创建一个新的图层</li><li>另外某些特定样式的元素会被提升成独立的渲染层（合成层），它跟普通图层不一样，有自己独立的图形上下文，使用GPU来加速渲染 <ul><li>iframe，3D transform，包含will-change、动画、过渡的opacity/transform/filter，启用硬解加速的 video 或采用 WebGL 的 canvas 等都会用独立的合成渲染层来渲染</li><li>合成层的位图合并是 GPU 来做的会更快；重绘不会影响其他层；对于一些动画效果无需重绘和回流</li><li>有的图层本身包含合成层并且具备一些特殊属性或者与合成层有某些情况下的重叠，都有可能造成自身也被提升为合成层的情况，太多的合成层会显著影响渲染性能，一个优化方法是使用 z-index 显式的提高合成层的层级</li></ul></li></ul></li><li>为每个图层生成绘制列表（绘制指令）</li></ol></li></ul><p>当渲染主线程生成好绘制指令之后就会提交给合成线程进行实际的绘制了</p><ul><li>合成线程 <ul><li>合成线程将不同的图层分块并将图块提交给栅格化线程池执行栅格化(光栅化)操作生成位图 <ul><li>图层分块的主要原因是要优先绘制视口涉及的区域（用户只能看到视口内的内容）</li></ul></li><li>合成线程发送绘制命令（DrawQuad）将位图提交给浏览器主进程合并然后显示到屏幕上</li><li>css动画是由合成线程直接渲染的，不会受js线程的影响</li></ul></li></ul></li><li><p>JS 线程，负责执行 JavaScript</p><ul><li>渲染主线程和 JS 是互斥的（因为 JS 会操作 DOM），同一时刻只能有一个执行</li></ul></li><li><p>事件触发线程，负责任务队列的调度和轮询</p></li><li><p>定时器线程，处理<code>setTimeout</code>和<code>setInterval</code>，它们需要经过一段时间才能被放入任务队列</p></li><li><p>http 请求线程，每次发起请求都会有新的线程来负责此次的请求生命周期</p></li><li><p>WebWorker 线程，单独运行 worker 脚本（注意它与 SharedWorker或者ServiceWorker 是不同的，后者是独立于所有页面的单独进程）</p></li></ul><p>实际的运行中，以上各种线程和进程会互相通信，各取所取，最终完成页面的渲染和响应。</p><h3>浏览器的一帧</h3><p>了解了这些线程的职责，我们就能了解浏览器在一帧的时间内做了什么事情：</p><ul><li>垂直同步信号（可以理解为屏幕渲染时钟信号）触发开始渲染新的一帧</li><li>处理用户事件回调，执行当前的宏任务和所有的微任务</li><li>执行<code>requestAnimationFrame</code>以及<code>IntersectionObserver</code>回调</li><li>处理 html 的变化，更新 dom</li><li>重新计算样式</li><li>重新计算布局树</li><li>更新图层树</li><li>重新生成绘制指令</li><li>合成线程处理图层，执行栅格化操作</li><li>合并位图并提交给 GPU</li><li>GPU 将收到的图块（纹理）渲染到屏幕上</li><li>有额外时间则执行<code>requestIdleCallback</code></li></ul><p>任何脚本的执行如果耗时太久都会导致浏览器在一帧中没有额外的时间处理渲染的事情，从而导致丢帧和卡顿。</p><h3>关于合成图层和普通图层</h3><p>浏览器中图层一般包含两大类：渲染图层（普通图层）以及复合图层（合成图层）</p><ul><li>渲染图层，是页面普通的文档流。我们虽然可以通过绝对定位，相对定位，浮动定位脱离文档流，但它仍然属于默认复合层(根层叠上下文)，共用同一个绘图上下文对象（GraphicsContext）。</li><li>复合图层，又称图形层。它会单独分配系统资源，每个复合图层都有一个独立的 GraphicsContext。（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li></ul><p>某些特殊的渲染层会被提升为复合成层（Compositing Layers），复合图层拥有单独的 GraphicsLayer，而其他不是复合图层的渲染层，则跟随第一个拥有 GraphicsLayer 的父层。</p><ul><li>3D 转换：translate3d，translateZ 依此类推；</li><li><code>&lt;video&gt;</code>，<code>&lt;canvas&gt;</code>和<code>&lt;iframe&gt;</code>元件;</li><li>transform 和 opacity 经由 Element.animate();</li><li>transform 和 opacity 经由 СSS 过渡和动画;</li><li>有合成层后代同时本身 fixed 定位</li><li>will-change;</li><li>拥有加速 CSS 过滤器的元素 filter;</li><li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li></ul><p>每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p>',19),r=[a],u={__name:"浏览器进程线程",setup(s,{expose:l}){return l({frontmatter:{}}),(c,n)=>(i(),e("div",o,r))}};export{u as default};
