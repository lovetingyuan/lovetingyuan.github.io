import{o as a,c as n,L as l}from"./vendor-Dj3S1wQe.js";const p={class:"markdown-body"},r=l(`<h2>单调栈和单调队列</h2><h3>单调栈</h3><p>顾名思义，就是栈中的元素必须保持单调增或单调减，一般用来维护某个范围内的最值</p><p>例如这道题<a href="https://leetcode.cn/problems/daily-temperatures/description/" target="_blank" rel="noopener">每日温度</a></p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8;" tabindex="0"><code class="language-js"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">var</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> dailyTemperatures</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#D73A49;--shiki-dark:#F97583;"> function</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#E36209;--shiki-dark:#FFAB70;">temperatures</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  const</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> stack</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> [] </span><span style="color:#6A737D;--shiki-dark:#6A737D;">// stack存放温度的下标</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  const</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(temperatures.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  for</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#D73A49;--shiki-dark:#F97583;">let</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="color:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> temperatures.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="color:#D73A49;--shiki-dark:#F97583;">++</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">    while</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (stack.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="color:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> temperatures[stack.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">at</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#D73A49;--shiki-dark:#F97583;">-</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)] </span><span style="color:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> temperatures[i]) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">      // 如果当前温度比栈顶高，那么需要弹出栈，使用二者下标相减的结果就是栈顶位置对应的答案</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">      const</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> top</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> stack.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      result[top] </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="color:#D73A49;--shiki-dark:#F97583;">-</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> top</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    stack.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(i)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  return</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> result</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><p>又例如：</p><p>给定一个非负数数组，要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和。（<a href="https://mp.weixin.qq.com/s?__biz=MzkxNDI1MTA1MA==&amp;mid=2247484407&amp;idx=1&amp;sn=6dd7483338b9997d40a115fe4ec95160&amp;chksm=c1700fb2f60786a417997494ad315bbe27847dbd654022bd895fbc81704563870c41fd9f5c1d&amp;cur_album_id=1890249534555897867&amp;scene=189#wechat_redirect" target="_blank" rel="noopener">链接</a>)</p><p>类似的题目还有 <a href="https://leetcode.cn/problems/sum-of-subarray-minimums" target="_blank" rel="noopener">子数组最小值之和</a>, <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图最大矩形</a>, <a href="https://leetcode.cn/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a>, <a href="https://leetcode.cn/problems/remove-duplicate-letters" target="_blank" rel="noopener">去除重复字母</a>, <a href="https://leetcode.cn/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字</a>，<a href="https://leetcode.cn/problems/beautiful-towers-i" target="_blank" rel="noopener">美丽塔</a></p><h3>单调队列</h3><p>类似于单调栈，同样保证队列中的值具备单调性</p><p>最经典的题目就是<a href="https://leetcode.cn/problems/sliding-window-maximum" target="_blank" rel="noopener">滑动窗口最大值</a></p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8;" tabindex="0"><code class="language-js"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">var</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> maxSlidingWindow</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#D73A49;--shiki-dark:#F97583;"> function</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#E36209;--shiki-dark:#FFAB70;">k</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 队列数组（存放的是元素下标，为了取值方便）</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  const</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> q</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 结果数组</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  const</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> ans</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  for</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#D73A49;--shiki-dark:#F97583;">let</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="color:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="color:#D73A49;--shiki-dark:#F97583;">++</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 若队列不为空，且当前元素大于等于队尾所存下标的元素，则弹出队尾</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">    while</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (q.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="color:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> nums[i] </span><span style="color:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> nums[q.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">at</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#D73A49;--shiki-dark:#F97583;">-</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)]) {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      q.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 入队当前元素下标</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    q.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(i)</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 判断当前最大值（即队首元素）是否在窗口中，若不在便将其出队</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">    while</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (q[</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="color:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="color:#D73A49;--shiki-dark:#F97583;">-</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      q.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">shift</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 当达到窗口大小时便开始向解集中添加队首元素作为解</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">    if</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="color:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="color:#D73A49;--shiki-dark:#F97583;">-</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      ans.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(nums[q[</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">]])</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  return</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> ans</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><p>类似的题目还有 <a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">绝对差不超过限制的最长子数组</a>，<a href="https://leetcode.cn/problems/jump-game-vi/" target="_blank" rel="noopener">跳跃游戏VI</a>, <a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" target="_blank" rel="noopener">和至少为K的最短子数组</a></p>`,13),i=[r],c={__name:"单调栈和队列",setup(o,{expose:s}){return s({frontmatter:{}}),(k,t)=>(a(),n("div",p,i))}};export{c as default};
