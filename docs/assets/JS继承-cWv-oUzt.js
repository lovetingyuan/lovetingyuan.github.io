import{o as a,c as n,J as l}from"./vendor-CYMqmtIB.js";const p={class:"markdown-body"},i=l(`<h2>JavaScript 继承实现</h2><h3>ES5 的实现</h3><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8;" tabindex="0"><code class="language-javascript"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#E36209;--shiki-dark:#FFAB70;">name</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#D73A49;--shiki-dark:#F97583;"> function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> getName</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  return</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.name</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#E36209;--shiki-dark:#FFAB70;">name</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#E36209;--shiki-dark:#FFAB70;">age</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  Parent.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, name)</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> age</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  constructor: {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    writable: </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    configurable: </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    enumerable: </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    value: Child,</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">getAge</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#D73A49;--shiki-dark:#F97583;"> function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> getAge</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  return</span><span style="color:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.age</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><h3>ES6</h3><p>对比于 ES6 规范中的 class 继承，上面的实现是少了一些细节的，看看 Babel 怎么弥补的</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8;" tabindex="0"><code class="language-javascript"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">class</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  static</span><span style="color:#E36209;--shiki-dark:#FFAB70;"> staticProp</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> &#39;static&#39;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  static</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> staticMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#E36209;--shiki-dark:#FFAB70;">a</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E36209;--shiki-dark:#FFAB70;">  instanceProp</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> &#39;instance&#39;</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  protoMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">class</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="color:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  static</span><span style="color:#E36209;--shiki-dark:#FFAB70;"> staticChild</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> &#39;static&#39;</span></span>
<span class="line"><span style="color:#E36209;--shiki-dark:#FFAB70;">  instanceChild</span><span style="color:#D73A49;--shiki-dark:#F97583;"> =</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> &#39;instance&#39;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  static</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> childStaticMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">staticMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#E36209;--shiki-dark:#FFAB70;">a</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#E36209;--shiki-dark:#FFAB70;">b</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  get</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> getterProp</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  protoMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">protoMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><p>Babel:</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8;" tabindex="0"><code class="language-javascript"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">var</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> Parent </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#6A737D;--shiki-dark:#6A737D;"> /*#__PURE__*/</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // static的方法直接挂到Parent上，但是是不可枚举的</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  _createClass</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Parent, </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, [</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      key: </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;staticMethod&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">      value</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> staticMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {},</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  ])</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#E36209;--shiki-dark:#FFAB70;">a</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">    _classCallCheck</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, Parent) </span><span style="color:#6A737D;--shiki-dark:#6A737D;">// 检查Parent不能直接调用</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 定义实例属性</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">    _defineProperty</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;instanceProp&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;instance&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 将原型方法放到Parent的原型对象上，这里的方法都是不可枚举的</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  _createClass</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Parent, [</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      key: </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;protoMethod&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">      value</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> protoMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">        return</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> &#39;parent proto&#39;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  ])</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  return</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> Parent</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">})()</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">// 将静态属性挂到Parent构造方法上</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">_defineProperty</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Parent, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;staticProp&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;static&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">var</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> Child </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#6A737D;--shiki-dark:#6A737D;"> /*#__PURE__*/</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="color:#E36209;--shiki-dark:#FFAB70;">_Parent</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // _inherits实现了两条继承路径</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 一是原型继承，和ES5一样，即 Child.prototype = Object.create(Parent.prototype, {...</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 二是构造方法的原型继承，即 Child.__proto__ = _Parent，这样就可以Object.getPrototypeOf(Child) === Parent，那如果不存在继承，那__proto__自然指向的是Function.prototype</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  _inherits</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Child, _Parent)</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // function _createSuper(Derived) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //   var hasNativeReflectConstruct = _isNativeReflectConstruct();</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //   return function _createSuperInternal() {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     // 获取到父类的构造方法</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     var Super = _getPrototypeOf(Derived), result;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     if (hasNativeReflectConstruct) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //       var NewTarget = _getPrototypeOf(this).constructor;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //       result = Reflect.construct(Super, arguments, NewTarget);</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     } else {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //       result = Super.apply(this, arguments);</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     }</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     if (result &amp;&amp; (_typeof(result) === &quot;object&quot; || typeof result === &quot;function&quot;)) {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //       return result;</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     }</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //     return _assertThisInitialized(this);</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  //   };</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // }</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 创建父类的构造方法，这里是对父类构造方法做了包装，上面这段注释给出了_createSuper的具体实现</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  var</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> _super </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> _createSuper</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Child)</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">  // 静态方法挂到Child上</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  _createClass</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Child, </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, [</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      key: </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;childStaticMethod&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">      value</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> childStaticMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">        // 这里调用的是父类的方法</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">        _get</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">_getPrototypeOf</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Child), </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;staticMethod&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  ])</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#E36209;--shiki-dark:#FFAB70;">a</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#E36209;--shiki-dark:#FFAB70;">b</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">    var</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> _this</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">    _classCallCheck</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, Child)</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 父类的构造方法在子类的上下文调用，这里会优先使用Reflect.construct()</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 使用Reflect可以实现先创建父类实例对象的效果，而不是拿着这里的this去调用父类构造方法，另一个好处是可以实现new.target</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 当然不支持Reflect就只能super.call(this)了</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    _this </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> _super.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, a)</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">    // 判断_this一定要存在，代表super要先被调用才能用this，然后定义实例属性</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">    _defineProperty</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">_assertThisInitialized</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(_this), </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;instanceChild&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;instance&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    _this.b </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">    return</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> _this</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">  _createClass</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Child, [</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      key: </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;protoMethod&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">      value</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> protoMethod</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">        _get</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">_getPrototypeOf</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;protoMethod&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D;">      // getter 属性是挂在到原型对象上的</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">      key: </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;getterProp&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">      get</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="color:#D73A49;--shiki-dark:#F97583;">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">() {},</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  ])</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">  return</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> Child</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">})(Parent)</span></span>
<span class="line"><span style="color:#6F42C1;--shiki-dark:#B392F0;">_defineProperty</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(Child, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;staticChild&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;static&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><p>Babel 会尽量按照规范去实现，由此可以看出 ES6 继承带来的变化：</p><ul><li>ES6 在实现原型继承的同时也会实现构造方法的继承，所以父类上的 static 属性子类也可以直接访问</li><li>ES6 在调用 super 的时候是先实例化父类，然后父类的实例对象在子类的构造方法上操作，ES5 是反过来，ES6 这样做主要目的是为了保留父类的一些内部属性和操作，比如继承内置对象时，如 Array，那<code>class MyArray extends Array {}</code>，这里实例化 MyArray 后调用 push 那么它的 length 是会变化的，ES5 无法做到这一点 <blockquote><p>子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法 Array 构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新 length 属性，这个内部属性无法在子类获取，导致子类的 length 属性行为不正常。</p></blockquote></li><li>ES6 的原型方法和静态方法都是<strong>不可枚举</strong>的，这些方法也都没有原型对象；ES6 支持 getter，但是是<strong>在原型对象上</strong>定义 set；class 必须用 new 调用，默认启用严格模式，类名具有暂时性死区等等</li></ul><h3>super</h3><p>额外说一下<code>super</code>，super 本身是个关键字，但是在代码上它却无法独立使用（单独使用<code>super</code>时它什么也不代表），合法的只有两种访问形式：</p><ul><li>作为方法来调用，此时只能出现在子类构造方法中，也就是必须先调用 super 才能使用 this；</li><li>也可以作为“对象”来使用： <ul><li>在原型方法（包括构造方法和 getter）中： <ul><li>访问 super 的属性时如<code>super.a</code>，这时的 super<strong>代表的是 this</strong>，也就是子类的实例对象</li><li>访问 super 上的方法时它代表的是<strong>父类的原型对象</strong>，如<code>super.parentMethod()</code>，这里的 parentMethod 中的 this 指向的是子类的实例对象</li></ul></li><li>在静态方法中访问 super 时它代表的是<strong>父类本身</strong>，如<code>super.staticParentMethod()</code>，这里的 staticParentMethod 中的 this 指向的是子类本身</li></ul></li></ul><p>不能以变量或者对象的眼光去看待 super，super 有自己的行事准则。</p>`,14),r=[i],c={__name:"JS继承",setup(o,{expose:s}){return s({frontmatter:{}}),(k,E)=>(a(),n("div",p,r))}};export{c as default};
