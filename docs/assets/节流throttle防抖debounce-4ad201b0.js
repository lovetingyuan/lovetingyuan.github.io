import{o as n,c as a,M as l}from"./vendor-0dbd748c.js";const p={class:"markdown-body"},o=l(`<h2>节流(throttle)和防抖(debounce)</h2><p>这两种函数执行策略都是针对短时间内函数被频繁触发执行的问题，比如 input 事件，resize 事件，scroll 事件，mousemove 等等，是改善程序性能的一种手段。</p><p>其中</p><ul><li>节流表示在设置的单位时间内，保证函数只被执行一次；</li></ul><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code class="language-javascript"><span class="line"><span style="color:#DCDCAA;">throttle</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">method</span><span style="color:#D4D4D4;">, </span><span style="color:#B5CEA8;">200</span><span style="color:#D4D4D4;">) </span><span style="color:#6A9955;">// method每次调用时间间隔都保证至少为200ms</span></span>
<span class="line"><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">throttle</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">func</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">delay</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">let</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">timer</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> (...</span><span style="color:#9CDCFE;">args</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">if</span><span style="color:#D4D4D4;"> (</span><span style="color:#9CDCFE;">timer</span><span style="color:#D4D4D4;">) </span><span style="color:#C586C0;">return</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">timer</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">setTimeout</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#6A9955;">// 也可以通过记录上一次执行时的时间戳对比现在的时间戳是否超出delay来决定是否执行函数</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">func</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">call</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, ...</span><span style="color:#9CDCFE;">args</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">timer</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">null</span></span>
<span class="line"><span style="color:#D4D4D4;">    }, </span><span style="color:#9CDCFE;">delay</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><ul><li>防抖表示在函数仅在频繁触发(间隔小于设置的时间)的最后一次执行；</li></ul><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code class="language-javascript"><span class="line"><span style="color:#DCDCAA;">debounce</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">method</span><span style="color:#D4D4D4;">, </span><span style="color:#B5CEA8;">200</span><span style="color:#D4D4D4;">) </span><span style="color:#6A9955;">// 在一段时间内，如果method触发的周期都小于200ms，那么只会最后执行一次</span></span>
<span class="line"><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">debounce</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">func</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">delay</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">let</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">timer</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> (...</span><span style="color:#9CDCFE;">args</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">clearTimeout</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">timer</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">timer</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">setTimeout</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">func</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">call</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, ...</span><span style="color:#9CDCFE;">args</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    }, </span><span style="color:#9CDCFE;">delay</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><p><code>lodash</code>提供了上面两个方法更为增强和细致的实现，<a href="https://github.com/lodash/lodash/blob/master/throttle.js" target="_blank" rel="noopener">throttle</a>, <a href="https://github.com/lodash/lodash/blob/master/debounce.js" target="_blank" rel="noopener">debounce</a>.</p>`,8),e=[o],C={__name:"节流throttle防抖debounce",setup(D,{expose:s}){return s({frontmatter:{}}),(c,r)=>(n(),a("div",p,e))}};export{C as default};
