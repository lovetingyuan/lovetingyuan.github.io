import{c as n,o as a,a as l}from"./index-93370dbe.js";const p={class:"markdown-body"},o=l(`<h2>JavaScript 继承实现</h2><h3>ES5 的实现</h3><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Parent</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">name</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"><span style="color:#4EC9B0;">Parent</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">getName</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">getName</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">name</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Child</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">age</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">call</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">age</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">age</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"><span style="color:#4EC9B0;">Child</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">Object</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">create</span><span style="color:#D4D4D4;">(</span><span style="color:#4EC9B0;">Parent</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">, {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">constructor:</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">writable:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">true</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">configurable:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">true</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">enumerable:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">false</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">value:</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">  },</span></span>
<span class="line"><span style="color:#D4D4D4;">})</span></span>
<span class="line"><span style="color:#4EC9B0;">Child</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">getAge</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">getAge</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">age</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><h3>ES6</h3><p>对比于 ES6 规范中的 class 继承，上面的实现是少了一些细节的，看看 Babel 怎么弥补的</p><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Parent</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">static</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">staticProp</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&#39;static&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">static</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">staticMethod</span><span style="color:#D4D4D4;">() {}</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">constructor</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">a</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">instanceProp</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&#39;instance&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">protoMethod</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">console</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">log</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Child</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">extends</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Parent</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">static</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">staticChild</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&#39;static&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#9CDCFE;">instanceChild</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&#39;instance&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">static</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">childStaticMethod</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">super</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">staticMethod</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">constructor</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">b</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">super</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">b</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">b</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">get</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">getterProp</span><span style="color:#D4D4D4;">() {}</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">protoMethod</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">super</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">protoMethod</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><p>Babel:</p><pre class="shiki" style="background-color:#1E1E1E;"><code><span class="line"><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;"> = </span><span style="color:#6A9955;">/*#__PURE__*/</span><span style="color:#D4D4D4;"> (</span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> () {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// static的方法直接挂到Parent上，但是是不可枚举的</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">_createClass</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;">, </span><span style="color:#569CD6;">null</span><span style="color:#D4D4D4;">, [</span></span>
<span class="line"><span style="color:#D4D4D4;">    {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">key:</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;staticMethod&#39;</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">value</span><span style="color:#9CDCFE;">:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">staticMethod</span><span style="color:#D4D4D4;">() {},</span></span>
<span class="line"><span style="color:#D4D4D4;">    },</span></span>
<span class="line"><span style="color:#D4D4D4;">  ])</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Parent</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">_classCallCheck</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;">) </span><span style="color:#6A9955;">// 检查Parent不能直接调用</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// 定义实例属性</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">_defineProperty</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;instanceProp&#39;</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;instance&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">a</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// 将原型方法放到Parent的原型对象上，这里的方法都是不可枚举的</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">_createClass</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;">, [</span></span>
<span class="line"><span style="color:#D4D4D4;">    {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">key:</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;protoMethod&#39;</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">value</span><span style="color:#9CDCFE;">:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">protoMethod</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;parent proto&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">      },</span></span>
<span class="line"><span style="color:#D4D4D4;">    },</span></span>
<span class="line"><span style="color:#D4D4D4;">  ])</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">Parent</span></span>
<span class="line"><span style="color:#D4D4D4;">})()</span></span>
<span class="line"><span style="color:#6A9955;">// 将静态属性挂到Parent构造方法上</span></span>
<span class="line"><span style="color:#DCDCAA;">_defineProperty</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;staticProp&#39;</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;static&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;"> = </span><span style="color:#6A9955;">/*#__PURE__*/</span><span style="color:#D4D4D4;"> (</span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> (</span><span style="color:#9CDCFE;">_Parent</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// _inherits实现了两条继承路径</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// 一是原型继承，和ES5一样，即 Child.prototype = Object.create(Parent.prototype, {...</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// 二是构造方法的原型继承，即 Child.__proto__ = _Parent，这样就可以Object.getPrototypeOf(Child) === Parent，那如果不存在继承，那__proto__自然指向的是Function.prototype</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">_inherits</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">_Parent</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// function _createSuper(Derived) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//   var hasNativeReflectConstruct = _isNativeReflectConstruct();</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//   return function _createSuperInternal() {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     // 获取到父类的构造方法</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     var Super = _getPrototypeOf(Derived), result;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     if (hasNativeReflectConstruct) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//       var NewTarget = _getPrototypeOf(this).constructor;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//       result = Reflect.construct(Super, arguments, NewTarget);</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     } else {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//       result = Super.apply(this, arguments);</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     if (result &amp;&amp; (_typeof(result) === &quot;object&quot; || typeof result === &quot;function&quot;)) {</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//       return result;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//     return _assertThisInitialized(this);</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">//   };</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// 创建父类的构造方法，这里是对父类构造方法做了包装，上面这段注释给出了_createSuper的具体实现</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">_super</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">_createSuper</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#6A9955;">// 静态方法挂到Child上</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">_createClass</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">, </span><span style="color:#569CD6;">null</span><span style="color:#D4D4D4;">, [</span></span>
<span class="line"><span style="color:#D4D4D4;">    {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">key:</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;childStaticMethod&#39;</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">value</span><span style="color:#9CDCFE;">:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">childStaticMethod</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#6A9955;">// 这里调用的是父类的方法</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#DCDCAA;">_get</span><span style="color:#D4D4D4;">(</span><span style="color:#DCDCAA;">_getPrototypeOf</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">), </span><span style="color:#CE9178;">&#39;staticMethod&#39;</span><span style="color:#D4D4D4;">, </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">).</span><span style="color:#DCDCAA;">call</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">      },</span></span>
<span class="line"><span style="color:#D4D4D4;">    },</span></span>
<span class="line"><span style="color:#D4D4D4;">  ])</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Child</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">b</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">_this</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">_classCallCheck</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// 父类的构造方法在子类的上下文调用，这里会优先使用Reflect.construct()</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// 使用Reflect可以实现先创建父类实例对象的效果，而不是拿着这里的this去调用父类构造方法，另一个好处是可以实现new.target</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// 当然不支持Reflect就只能super.call(this)了</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">_this</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">_super</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">call</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">, </span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// 判断_this一定要存在，代表super要先被调用才能用this，然后定义实例属性</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">_defineProperty</span><span style="color:#D4D4D4;">(</span><span style="color:#DCDCAA;">_assertThisInitialized</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">_this</span><span style="color:#D4D4D4;">), </span><span style="color:#CE9178;">&#39;instanceChild&#39;</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;instance&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">_this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">b</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">b</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">_this</span></span>
<span class="line"><span style="color:#D4D4D4;">  }</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#DCDCAA;">_createClass</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">, [</span></span>
<span class="line"><span style="color:#D4D4D4;">    {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">key:</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;protoMethod&#39;</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">value</span><span style="color:#9CDCFE;">:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">protoMethod</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#DCDCAA;">_get</span><span style="color:#D4D4D4;">(</span><span style="color:#DCDCAA;">_getPrototypeOf</span><span style="color:#D4D4D4;">(</span><span style="color:#4EC9B0;">Child</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">), </span><span style="color:#CE9178;">&#39;protoMethod&#39;</span><span style="color:#D4D4D4;">, </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">).</span><span style="color:#DCDCAA;">call</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">      },</span></span>
<span class="line"><span style="color:#D4D4D4;">    },</span></span>
<span class="line"><span style="color:#D4D4D4;">    {</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#6A9955;">// getter 属性是挂在到原型对象上的</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#9CDCFE;">key:</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&#39;getterProp&#39;</span><span style="color:#D4D4D4;">,</span></span>
<span class="line"><span style="color:#D4D4D4;">      </span><span style="color:#DCDCAA;">get</span><span style="color:#9CDCFE;">:</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">get</span><span style="color:#D4D4D4;">() {},</span></span>
<span class="line"><span style="color:#D4D4D4;">    },</span></span>
<span class="line"><span style="color:#D4D4D4;">  ])</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">Child</span></span>
<span class="line"><span style="color:#D4D4D4;">})(</span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#DCDCAA;">_defineProperty</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;staticChild&#39;</span><span style="color:#D4D4D4;">, </span><span style="color:#CE9178;">&#39;static&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre><p>Babel 会尽量按照规范去实现，由此可以看出 ES6 继承带来的变化：</p><ul><li>ES6 在实现原型继承的同时也会实现构造方法的继承，所以父类上的 static 属性子类也可以直接访问</li><li>ES6 在调用 super 的时候是先实例化父类，然后父类的实例对象在子类的构造方法上操作，ES5 是反过来，ES6 这样做主要目的是为了保留父类的一些内部属性和操作，比如继承内置对象时，如 Array，那<code>class MyArray extends Array {}</code>，这里实例化 MyArray 后调用 push 那么它的 length 是会变化的，ES5 无法做到这一点 <blockquote><p>子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法 Array 构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新 length 属性，这个内部属性无法在子类获取，导致子类的 length 属性行为不正常。</p></blockquote></li><li>ES6 的原型方法和静态方法都是<strong>不可枚举</strong>的，这些方法也都没有原型对象；ES6 支持 getter，但是是<strong>在原型对象上</strong>定义 set；class 必须用 new 调用，默认启用严格模式，类名具有暂时性死区等等</li></ul><h3>super</h3><p>额外说一下<code>super</code>，super 本身是个关键字，但是在代码上它却无法独立使用（单独使用<code>super</code>时它什么也不代表），合法的只有两种访问形式：</p><ul><li>作为方法来调用，此时只能出现在子类构造方法中，也就是必须先调用 super 才能使用 this；</li><li>也可以作为“对象”来使用： <ul><li>在原型方法（包括构造方法和 getter）中： <ul><li>访问 super 的属性时如<code>super.a</code>，这时的 super<strong>代表的是 this</strong>，也就是子类的实例对象</li><li>访问 super 上的方法时它代表的是<strong>父类的原型对象</strong>，如<code>super.parentMethod()</code>，这里的 parentMethod 中的 this 指向的是子类的实例对象</li></ul></li><li>在静态方法中访问 super 时它代表的是<strong>父类本身</strong>，如<code>super.staticParentMethod()</code>，这里的 staticParentMethod 中的 this 指向的是子类本身</li></ul></li></ul><p>不能以变量或者对象的眼光去看待 super，super 有自己的行事准则。</p>`,14),D=[o],C={__name:"JS继承",setup(e,{expose:s}){return s({frontmatter:{}}),(c,r)=>(a(),n("div",p,D))}};export{C as default};
