import{o,f as t,P as c}from"./vendor-BH-iNz4O.js";const r={class:"markdown-body"},a=c('<h2>React性能优化</h2><h3>使用 React.memo (PureComponent or shouldComponentUpdate)</h3><ol><li><p>使用 <code>memo</code> 来尽量避免React组件不必要的重渲染（尤其是对于大而重的组件），因为大部分情况下我们期望的是props变化组件才重渲染。但是值得注意的是单纯的使用 <code>memo</code> 是很脆弱的，比如我们经常向组件属性传递对象字面量或者函数，这都很可能无法实现这样的优化初衷</p></li><li><p>对于传递给组件的props，如果是对象类型的属性，我们可以使用 <code>useMemo</code> <code>useCallback</code> <code>useRef</code> 来减少引用的变更</p></li><li><p>更进一步的，我认为应该尽量减少组件的props数量，props过多不利于达成 <code>memo</code> 的优化，很多组件用不到某些props但是为了传递它们而不得不接收从而造成props drilling。其实很多时候我们是可以把（并且也应该这样）组件的状态或者属性放到外部store中的，我们在组件内部订阅和消费这些外部状态，而不是通过props去传递。</p></li></ol><h3>尽量减少re-render</h3><ol><li>除了memo的手段外，还需要注意在编码的时候避免不必要的重渲染。最常见的情况是，过度依赖状态变更来触发新的状态变化，例如在 <code>useEffect</code> 中触发新的状态变化。大部分的状态变化其实都可以放到事件处理函数中。</li><li>另外需要尽量避免定义过多的状态，如果多个状态是整体的就应该合并成一个状态；如果有的状态是可以派生的，那就不应该定义而是应该直接计算。</li></ol><h3>使用 useMemo useState-lazy-initializer</h3><ol><li>对于计算昂贵的数据或者昂贵的组件（jsx），可以使用 <code>useMemo</code> 来进行缓存</li><li>对于数据量比较大的状态，我们可以给 <code>useState</code> 传递一个函数，因为这个函数只会执行一次</li></ol><h3>使用 startTransition useTransition</h3><ol><li>如果某些状态更新会导致一些长任务的话，可以使用 <code>startTransition</code> 来包裹，比如当你发现某些状态变化引起的组件重渲染导致UI卡顿的时候，可以使用 <code>startTransition</code>，这样状态更新的优先级会被降低而优先保证UI的流畅</li></ol><h3>使用 useDeferredValue</h3><p>如果某个状态会频繁快速的更新而导致部分UI频繁重渲染，可以使用 <code>useDeferredValue</code> 来获取一个类似于防抖版本的值，这样可以避免某些UI频繁更新，尤其是这些UI优先级较低但是负载又较高的时候。</p><p>想象一下你的组件中包含一些需要及时更新的部分和不那么重要的部分，当状态频繁变化时，所有的部分都会频繁渲染。如果不重要的部分使用了 <code>useDeferredValue</code> 返回的值，那么在下一次状态更新时，不重要的部分的状态并不会变化，这样可以借助于 <code>React.memo</code> 来避免这部分的渲染，从而保证重要的部分可以及时得到更新。当重要部分渲染完毕后，<code>useDeferredValue</code> 会自动触发第二次渲染，这时候会使用更新后的状态，此时如果状态再次发生变化，react会中断本次渲染，然后再继续新的渲染。（<a href="https://www.joshwcomeau.com/react/use-deferred-value/" target="_blank" rel="noopener">文章</a>）</p><h3>谨慎更新 React.Context 的value</h3><p>React Context中的值变化时，访问到这个context的组件都会重新渲染，正确的做法是将 Context根据不同的value属性来拆分</p><h3>合理拆分和组合组件</h3><p>避免很长的组件。组件的职责应该单一，所以它本应该就不应该大而杂乱。也许你只是更新了一个文本需要用到的状态，但是整个组件都要重新渲染。</p><ol><li>可以解耦的逻辑一律放到组件外部，组件内部只负责调用，传递值，获取结果</li><li>可复用的状态和逻辑一律包装成hook</li><li>考察组件是否可以拆分为不同的更小的组件，如果可以抽离新的组件，那就意味着避免了相应的状态变更引起其他无关的UI部分的重渲染</li></ol><h3>React Compiler</h3><p><a href="https://react.dev/learn/react-compiler" target="_blank" rel="noopener">https://react.dev/learn/react-compiler</a></p><p>另外还有一些跟性能有关的值得注意的点，例如合理的使用 <code>key</code>；避免组件层级过深，节点数量过多；谨慎在高层级的组件处进行状态变更；延迟渲染，缓存渲染（长列表、tab、dialog等）；组件异步拆分；组件单例化等</p><p>最后不要过分追求react性能的优化，发现了性能问题再去优化，代码的可读性和可维护性远比一些细微的性能优化更值得投入精力。</p>',21),l=[a],h={__name:"React性能优化",setup(d,{expose:e}){return e({frontmatter:{}}),(p,i)=>(o(),t("div",r,l))}};export{h as default};
