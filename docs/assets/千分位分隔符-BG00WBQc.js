import{o as a,f as e,P as o}from"./vendor-BH-iNz4O.js";const r={class:"markdown-body"},l=o(`<h3>千分位分隔符</h3><p>一串数字，使用千分位分隔符分隔开 如 100000 -&gt; 100,000</p><p>10000000 -&gt; 10,000,000</p><p>最简单的方式是使用正则表达式来实现，从末尾开始向前，每三个数字就插入一个分隔符</p><p><code>/(\\d{3})+$/</code></p><p>这样会匹配末尾之前三的整数倍的数字</p><blockquote><p>关于正则量词可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers</a></p></blockquote><p>但实际我们要匹配的是三个数字之前的那个空白位置，分隔符需要被插入到该位置。这时需要用到前向断言<code>x(?=y)</code>，这个正则会匹配 x 但是要求 x 后面必须跟着 y，<code>(?=(\\d{3}))</code>这样会匹配一个空白位置，后面跟着三个数字，这样正则变成了 <code>(?=(\\d{3})+$)</code></p><blockquote><p>关于正则断言可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions</a></p></blockquote><p>接下来需要处理开头的特殊情况，不处理的话如果数字恰好是三的整数倍，那么开头也会被插入分隔符 我们只需要不匹配开头即可，<code>/(?=(\\B\\d{3})+$)/g</code>，这里的元字符<code>\\B</code>表示非单词边界，宽度为 0</p><blockquote><p>关于正则元字符可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes</a></p></blockquote><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8;" tabindex="0"><code class="language-js"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583;">var</span><span style="color:#24292E;--shiki-dark:#E1E4E8;"> str </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> &#39;10000000000&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">  reg </span><span style="color:#D73A49;--shiki-dark:#F97583;">=</span><span style="color:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="color:#032F62;--shiki-dark:#DBEDFF;">(?=(</span><span style="color:#D73A49;--shiki-dark:#F97583;">\\B</span><span style="color:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="color:#D73A49;--shiki-dark:#F97583;">{3}</span><span style="color:#032F62;--shiki-dark:#DBEDFF;">)</span><span style="color:#D73A49;--shiki-dark:#F97583;">+$</span><span style="color:#032F62;--shiki-dark:#DBEDFF;">)</span><span style="color:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="color:#D73A49;--shiki-dark:#F97583;">g</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(str.</span><span style="color:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">(reg, </span><span style="color:#032F62;--shiki-dark:#9ECBFF;">&#39;,&#39;</span><span style="color:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="color:#6A737D;--shiki-dark:#6A737D;">// 10,000,000,000</span></span></code></pre><p>规则 描述 \\ 转义 ^ 匹配输入的开始 $ 匹配输入的结束</p><ul><li>匹配前一个表达式 0 次或多次</li></ul><ul><li>匹配前面一个表达式 1 次或者多次。等价于 {1,} ? 匹配前面一个表达式 0 次或者 1 次。等价于{0,1} . 默认匹配除换行符之外的任何单个字符 x(?=y) 匹配’x’仅仅当’x’后面跟着’y’。这种叫做先行断言 (?&lt;=y)x 匹配’x’仅当’x’前面是’y’.这种叫做后行断言 x(?!y) 仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找 (?&lt;!y)x 仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找 x|y 匹配‘x’或者‘y’ {n} n 是一个正整数，匹配了前面一个字符刚好出现了 n 次 {n,} n是一个正整数，匹配前一个字符至少出现了n次 {n,m} n 和 m 都是整数。匹配前面的字符至少n次，最多m次 [xyz] 一个字符集合。匹配方括号中的任意字符 [^xyz] 匹配任何没有包含在方括号中的字符 \\b 匹配一个词的边界，例如在字母和空格之间 \\B 匹配一个非单词边界 \\d 匹配一个数字 \\D 匹配一个非数字字符 \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符 \\S 匹配一个非空白字符 \\w 匹配一个单字字符（字母、数字或者下划线） \\W 匹配一个非单字字符</li></ul>`,15),p=[l],k={__name:"千分位分隔符",setup(n,{expose:s}){return s({frontmatter:{}}),(t,c)=>(a(),e("div",r,p))}};export{k as default};
