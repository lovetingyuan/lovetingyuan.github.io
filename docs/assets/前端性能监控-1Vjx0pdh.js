import{o,f as r,P as t}from"./vendor-CYDcDHDY.js";const a={class:"markdown-body"},c=t('<h2>前端监控</h2><p>浏览器端的监控主要有以下几个方面：</p><ul><li>性能监控 <ul><li>加载性能</li><li>渲染帧率</li></ul></li><li>错误监控 <ul><li>资源错误</li><li>JS 运行错误</li></ul></li><li>埋点上报</li></ul><h3>性能监控</h3><h4>指标定义</h4><p>衡量页面加载的速度有很多指标，比如：</p><ul><li><p>TTFB: Time to First Byte <img src="https://web.dev/static/articles/ttfb/image/performance-navigation-timing-timestamp-diagram.svg?hl=zh-cn" alt="full-process"><img src="https://web.dev/articles/ttfb/image/good-ttfb-values.svg" alt="TTFB"> 测量从导航或者重定向开始到接收到服务端第一个字节之间的耗时，如上图即测量 startTime 和 responseStart 之间的用时。</p></li><li><p>FP: First paint 只要屏幕上有任何变化的开始瞬间</p></li><li><p>FCP: First contentful paint 第一次有DOM相关的内容（如文本、图片、媒体等）渲染，通常紧接着FP发生</p></li><li><p>FMP: First meaningful paint（被<code>LCP</code>取代）</p></li><li><p><a href="https://web.dev/lcp/" target="_blank" rel="noopener"><code>LCP</code></a>: <strong>Largest contentful paint</strong><img src="https://web.dev/articles/vitals/image/largest-contentful-paint-ea2e6ec5569b6.svg" alt="LCP"> 表示当前处于 viewport 内最大（未拉伸且实际显示的大小）的图片（可能是背景图）或者 video 或者文本块渲染完成的时间（值得注意的是最大内容通常会动态变化）；</p></li><li><p><a href="https://web.dev/fid/" target="_blank" rel="noopener"><code>FID</code></a>: <strong>First input delay</strong></p><p>表示首次交互延迟时间，通常发生在<code>FCP</code>和<code>TTI</code>之间，此时用户点击了链接或者按钮或者进行了输入，页面却可能被主线程阻塞无反应（被<code>INP</code>取代）；</p></li><li><p><a href="https://web.dev/articles/inp" target="_blank" rel="noopener"><code>INP</code></a>: <strong>Interaction to Next Paint</strong><img src="https://web.dev/static/articles/vitals/image/inp-thresholds.svg" alt="INP"> 表示用户交互（点击、触摸、按键等）时，页面给出反应的时间，最好不应大于200ms。整体包含输入（从交互开始到调用事件处理函数前）、处理（运行事件处理函数）、呈现（对DOM变化重新渲染并呈现）三个阶段。该指标相比<code>FID</code>能更加全面反映页面整体的响应情况。</p><p>优化INP指标重点在于优化JS的执行效率，避免长任务，优化算法，通过代码分割按需加载减少非必要代码量，避免频繁的DOM操作，节流防抖，预加载关键资源等。</p></li><li><p><a href="https://web.dev/cls/" target="_blank" rel="noopener"><code>CLS</code></a>: <strong>Cumulative layout shift</strong><img src="https://web.dev/static/articles/vitals/image/cumulative-layout-shift-t-5d49b9b883de4.svg" alt="CLS"> 用来衡量页面稳定性，用户不希望在浏览页面时被突然加载上的图片或者 iframe 或者一些动态内容将当前的内容弹开，应该尽量避免 dom 插入或移动，并给置换元素提前设定好大小。</p><p>优化CLS重点在于给元素设置确定的尺寸和宽高比，给动态内容留出空间，例如采用占位、loading等，避免在已有的内容前面或上方添加内容，也要避免频繁的内容变动，减少页面回流，尽量使用CSS动画，优化字体加载（font-display），利用CSS contain属性做隔离优化等。</p></li><li><p>TTI: Time to Interactive 测量从<code>FCP</code>开始5秒内没有长任务运行且没有2个以上请求进行的情况下往前回溯至5秒前的最后一个长任务结束的时间点</p></li><li><p>TBT: Total Blocking Time 总阻塞时间 (TBT) 指标用于衡量在 <code>FCP</code> 之后主线程被阻塞的时间足以阻止输入响应的总时间。具体来说就是统计到TTI之前所有长任务的阻塞时间之和（阻塞时间指的是每个长任务去除掉50ms之后的时间）。</p></li></ul><h4>指标获取</h4><p>我们可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener"><code>performance</code></a>API 来获取或者计算出大部分的指标。performance API 仍处于标准化的过程中，其中的属性和方法仍可能会变化。可以通过<code>performance.getEntries()</code>来获取当前可用的性能指标(<code>PerformanceEntry</code>)，每个指标都会包含<code>duration</code>,<code>entryType</code>,<code>name</code>,<code>startTime</code>这几个属性，其中<code>duration</code>就表示耗时。</p><p>这些指标包含有不同的类型：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener"><code>PerformanceNavigationTiming</code></a>，这个指标中包含了页面导航、加载的一些时间点，包括从页面请求发出到 DNS 查找到重定向到响应结束再到 dom 树构建等丰富的时间节点，这些属性也可以通过<code>performance.timing</code>来获取；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceMark" target="_blank" rel="noopener"><code>PerformanceMark</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceMeasure" target="_blank" rel="noopener"><code>PerformanceMeasure</code></a>，这个指标供用户自己进行时间打点，可以调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/mark" target="_blank" rel="noopener"><code>performance.mark(name)</code></a>开始计时，调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/measure" target="_blank" rel="noopener"><code>performance.measure(name)</code></a>结束计时，然后通过<code>performance.getEntriesByName(name)</code>就能拿到测量的结果；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceResourceTiming" target="_blank" rel="noopener"><code>PerformanceResourceTiming</code></a>，这个指标用来衡量资源加载和 API 请求的情况，包括重定向，DNS 查找，请求开始结束等等的时间；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformancePaintTiming" target="_blank" rel="noopener"><code>PerformancePaintTiming</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEventTiming" target="_blank" rel="noopener"><code>PerformanceEventTiming</code></a>，这两个指标包含<code>FP</code>,<code>FCP</code>, <code>first-input</code>;</li><li>另外还有<code>PerformanceServerTiming</code>,<code>PerformanceLongTaskTiming</code>,<code>PerformanceElementTiming</code>,<code>PerformanceFrameTiming</code>等等。</li></ul><p>性能指标的衡量是个动态的过程，随着页面渲染和交互的不断进行，其中的一些指标是会不断变化的，可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver" target="_blank" rel="noopener"><code>PerformanceObserver</code></a>来进行监听，它可以监听例如<code>first-input</code>(可以用来计算 FID), <code>largest-contentful-paint</code>, <code>layout-shift</code>(可以用来计算 CLS), <code>navigation</code>, <code>mark</code>&amp;<code>measure</code>等指标的变化。</p><p>对于 <code>LCP</code>, <code>INP</code>, <code>CLS</code>这三个指标，可以使用google的 <a href="https://github.com/GoogleChrome/web-vitals" target="_blank" rel="noopener">web-vitals</a> 来获取，更全面的指标可以使用 <a href="https://github.com/Zizzamia/perfume.js" target="_blank" rel="noopener">perfume.js</a> 来统计。</p><p>Nodejs 同时也对 performance API 提供了支持，实现了<a href="https://nodejs.org/api/perf_hooks.html" target="_blank" rel="noopener">perf_hooks</a>接口。</p><p>一些页面性能统计工具：</p><ul><li><a href="https://pagespeed.web.dev/?hl=zh-cn" target="_blank" rel="noopener">https://pagespeed.web.dev/?hl=zh-cn</a></li><li><a href="https://www.webpagetest.org/" target="_blank" rel="noopener">https://www.webpagetest.org/</a></li></ul><p>值得注意的是，对于单页应用SPA来讲，需要额外关注路由切换时的性能统计，包括路由切换的耗时以及相关的一些动态指标。</p><h4>渲染性能</h4><p>页面渲染问题，一般可以在开发阶段进行评估和发现。Long-task 的 JS，频繁的重绘回流，大量的 dom 节点，复杂的动画，过高的 CPU 内存占用等都会引起掉帧问题。Chrome 浏览器的控制台提供了功能强大的 performance 面板，以及 rendering 工具（可以查看实时帧率和重绘回流），JavaScript profiler 工具，performance monitor 工具（CPU，内存，重绘回流，dom 节点数等），coverage 工具等工具集，可以帮助快速定位性能问题。考虑到可能的掉帧问题，可以利用<code>requestAnimationFrame</code>来计算渲染帧率，例如 <a href="https://github.com/darsain/fpsmeter" target="_blank" rel="noopener">fpsmeter</a>，然后针对有连续掉帧的场景进行上报。</p><hr><h3>错误监控</h3><h4>JS 及资源加载错误</h4><ul><li><code>window.onerror</code>或<code>window.addEventListener(&#39;error&#39;, handler)</code><ul><li>用来捕获 JS 运行时错误（包括语法错误），回调参数包含错误信息，脚本 url，行号，列号等； 有时候脚本是从不同的域加载的，这时是无法获取错误的详细信息的，解决办法是为 script 标签加上<code>crossorigin</code>属性并让服务器开启<code>CORS</code>；</li><li>资源加载错误不会冒泡，所以只能通过<code>window.addEventListener(&#39;error&#39;, handler, true)</code>在捕获阶段捕获；</li></ul></li></ul><h4>Promise 错误</h4><ul><li><code>window.onunhandledrejection</code>或<code>window.addEventListener(&#39;unhandledrejection&#39;, handler)</code><ul><li>用来捕获没有 reject 或 catch 来处理的<code>Promise</code>错误，回调的错误对象包含该 promise 以及<code>reason</code></li><li>也可以捕获<code>async/await</code>中发生的错误，但对于<code>await</code>后面的 promise 一般都需要进行错误处理，避免执行中断</li></ul></li></ul><h4>接口错误</h4><ul><li>对于接口请求，通常会封装成一系列方法供业务调用，此时可以很方便的集中处理接口错误； 否则可以通过 patch 的方法来实现对 API 错误的追踪：<code>fetch</code>可以直接被 overwrite，<code>XMLHttpRequest</code>可以 patch 原型上的<code>open</code>，<code>send</code>等方法，拿到<code>xhr</code>实例然后监听错误。</li></ul><hr><h3>数据埋点上报</h3><p>一般需要对用户数据以及用户行为进行上报，用户数据包括账户信息，设备信息等，用户行为包括访问路径，访问时长，页面交互等；</p><p>埋点方式一般有代码埋点（主动调用上报 API，或者采用 dataset 或指令等声明式），可视化埋点（如记录控件 xpath），无痕埋点（如通过事件委托全量记录用户操作）</p><p>上报方式一般采用 1px 图片 Get 请求，将数据放在 query 中；或者采用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon" target="_blank" rel="noopener"><code>navigator.sendBeacon</code></a>，它是异步的 post 请求，可以保证页面卸载也能完成上报，并且不会与接口请求竞争，是理想的上报方式</p>',32),n=[c],m={__name:"前端性能监控",setup(i,{expose:e}){return e({frontmatter:{}}),(d,p)=>(o(),r("div",a,n))}};export{m as default};
