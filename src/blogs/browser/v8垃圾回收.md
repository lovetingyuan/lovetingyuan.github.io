[comment]: <browser> (title: 'v8引擎的垃圾回收', keywords: 'GC, ram', date: '2020-8-7')

### V8引擎的垃圾回收

代码运行时需要分配内存，通常会有三种分配策略，分别是静态分配，栈分配，堆分配，JS是高度动态的语言，所以V8会采用栈内存和堆内存来运行JS代码。

* 栈内存

  栈内存主要存储一些基础类型变量和复杂对象的指针或者资源的句柄等。栈内存是一段连续的小内存，所以它不适合存放大量的数据，函数调用这种就适合用栈内存来存储，包括静态数据，上下文结构，临时变量等，函数调用完成后就会出栈，相应的栈空间就会被系统释放。V8中可以通过`--stack_size`来调整栈内存的大小。

* 堆内存：堆内存主要存储对象数据。V8把堆内存分成了几个部分，GC则发生在其中的 新生代空间 和 老生代空间 中，
  * 新生代空间：存储新生成的对象，这里的数据存活比较短，会经常被GC
  * 老生代空间：这里存储比较持久（经历两次新生代GC仍存活）的对象
  * 大对象空间：存放体积特别大（比其他空间都大）的对象，这里的对象不会被回收
  * 代码空间：存放代码，包括JIT编译的指令和运行信息
  * MAP空间：存储隐藏类（用来提升属性访问速度）

![alt](https://s1.ax1x.com/2020/08/07/afmdAA.png)

V8的GC发生在新生代空间和老生代空间中，它们存放着我们代码中声明的大部分对象，包括变量对象和活动对象。之所以采取分代策略是因为对象的创建是频繁的，并且大部分生命都是短暂的，但是经过GC存活后一般认为继续用到的可能性比较大。

* 新生代空间
  新生代空间是比较小的，它分成两个大小相同的部分（from区和to区），主要由Scavenger(Minor GC)来负责管理，也称为清道夫算法，采用Cheney算法实现，这是一种广度优先算法。空间的大小可以用`--min_semi_space_size`和`--max_semi_space_size`(KB)来设置。在64位系统中最大32MB，32位系统最多是16MB。

  to这个半区是空的，from半区则是正在使用的区域，当from满了的时候，Minor GC就会清理from中无用的对象，然后将存活的对象复制到to中，这样to就变成了from，原来的from就变成了to。这个过程使用的便是Cheney算法。这个过程中如果对象经历了两次GC仍存活或者复制到to的时候to的占用达到了25%那么对象就会晋升到老生代空间中。

* 老生代空间
  老生代空间存放的对象比较多，数据量比较大，采用的是不同的GC算法：Mark-Sweep & Mark-Compact(Major GC)，标记清除和标记整理。空间大小可以通过`--max_old_space_size`(MB)来设置。在64位系统中最大为1400MB，32位系统为700MB。V8之所以对内存大小限制的比较低一是因为浏览器环境内存用量一般没那么大，二是因为太大的堆内存会使得GC时间过长，阻塞代码的运行。老生代中的对象有两类，一类是包含指针的对象，新生代刚过来的对象一般就属于这一类，另一类是只包含数据的对象。

  标记清除分为两个阶段，标记阶段首先会从已知的活动对象进行遍历，对存活的对象打上标记，清除阶段会对没有标记的对象直接清除。这样的过程多了会使得内存碎片越来越多导致可用空间越来越少，这时标记整理的过程会启动，标记存活的对象会被紧凑的移动到一端，然后整理剩余的内存。

  * 增量标记
    进行标记的过程采用的是强三色标记算法（深度优先）来实现，每个对象用两个比特位表示三种颜色，黑色表示对象可以被访问应保留，白色表示不可达应清除，灰色表示自身可达但后续节点还未处理，需要下一次GC继续处理，处理完后灰色会变成黑色，否则白色都需要变成灰色。等到非黑即白的时候，就可以进行清除了。借助于这样的算法，V8实现了增量标记的过程。由于代码运行会对已经标记的节点造成突变，V8采用写屏障的机制保证已经变黑的节点不会引用白色节点，而是将白色节点置灰，这保证了白色节点绝对不可达。增量处理的过程也是延迟清除和增量整理这样的优化手段的基础。

  * 平行标记
    V8会启用额外的工作线程来同时推进标记的工作，这样能提高GC吞吐量。V8维护一个标记工作表，负责向工作线程派发标记任务，线程完成标记后会将结果发布到全局而自身则继续新的标记工作。

  * 并发标记
    并发标记同平行标记类似，但是它的工作线程是和JS线程并发执行的，不会阻塞代码的运行。当然问题就是代码的运行会对已经标记的结果产生影响造成偏差，通过写屏障和原子操作可以解决这个问题。详情可以查看[这篇文章](https://v8.js.cn/blog/concurrent-marking/)。

  ![alt](https://v8.js.cn/_img/concurrent-marking/11.svg)

V8的GC是准确式的GC，意味着它能准确的区分一段内存中存放的是整数还是指针（通过字的末尾一位），从而避免了误把数据当作指针从而造成错误标记的情况。这就是V8垃圾回收运行的大体过程，实际的算法和策略是非常复杂的并且还在不断迭代优化，包括新生代清理，老生代整理都运用了并行和增量的手段来优化，还有最近发布的指针压缩技术等。
